{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DisruptSC","text":"<p>Version 1.1.7</p> <p>DisruptSC is a spatial agent-based model for simulating supply chain disruptions. It models economic agents (firms, households, countries) connected through transport networks and supply chains to analyze the impact of disruptions on economic systems.</p>"},{"location":"#key-features","title":"Key Features","text":"\ud83c\udf0d Spatial Modeling Agents are located on transport networks with realistic geographic constraints \ud83c\udfed Multi-Agent System Firms, households, and countries with distinct behaviors and interactions \ud83d\ude9b Transport Networks Multiple transport modes (roads, maritime, railways, airways, pipelines) \ud83d\udcbc Economic Foundations Based on Multi-Regional Input-Output (MRIO) tables \u26a1 Disruption Analysis Model transport disruptions and capital destruction events \ud83d\udcca Rich Outputs Detailed economic and spatial results for policy analysis"},{"location":"#quick-start","title":"Quick Start","text":"<p>New to DisruptSC?</p> <p>Start with our Installation Guide and then try the Quick Start Tutorial.</p> <pre><code># Clone repo\ngit clone \n\n# Install dependencies\nconda env create -f dsc-environment.yml\nconda activate dsc\n\n# Set up data (choose one option)\ncd disrupt-sc\nmkdir input  # Option 1: create your set of input data\ngit submodule add &lt;data-repo-url&gt; data     # Option 2: Git disrupt-sc-data submodule (invitation-only)\n\n# Validate inputs\npython validate_inputs.py Testkistan\n\n# Run a simulation\npython disruptsc/main.py Testkistan\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"\ud83c\udfdb\ufe0f Policy Analysis Assess economic impacts of infrastructure disruptions for policy planning \ud83c\udf2a\ufe0f Disaster Response Model supply chain vulnerabilities during natural disasters \ud83d\udea7 Infrastructure Planning Evaluate critical transport links and redundancy needs"},{"location":"#model-workflow","title":"Model Workflow","text":"<pre><code>graph TD\n    A[Setup Transport Network] --&gt; B[Create Agents]\n    B --&gt; C[Build Supply Chain Network]\n    C --&gt; D[Optimize Logistic Routes]\n    D --&gt; E[Initialize Economic Variables]\n    E --&gt; F[Run Baseline Simulation]\n    F --&gt; G[Apply Disruptions]\n    G --&gt; H[Analyze Results]</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>DisruptSC uses a modular architecture with clear separation of concerns:</p> <ul> <li>Agents: Economic actors with spatial locations and behaviors</li> <li>Networks: Transport infrastructure and supply chain relationships  </li> <li>Disruptions: Events that affect agent capabilities or network availability</li> <li>Simulation: Time-stepped execution with data collection</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"\ud83d\udcd6 Documentation Comprehensive guides and API reference in this documentation \ud83d\udc1b Issues Report bugs and request features on GitHub Issues \ud83d\udcac Discussions Contact the lead author directly"},{"location":"#citation","title":"Citation","text":"<p>If you use DisruptSC in your research, please cite:</p>"},{"location":"#apa-style","title":"\ud83d\udcda APA Style","text":"<p>Colon, C., Hallegatte, S., &amp; Rozenberg, J. (2021). Criticality analysis of a country\u2019s transport network via an agent-based supply chain model. Nature Sustainability, 4(3), 209-215.</p>"},{"location":"#bibtex","title":"\ud83d\udd16 BibTeX","text":"<p><pre><code>@article{colon2021disruptsc,\n  author  = {Celian Colon and Stephane Hallegatte and Julie Rozenberg},\n  title   = {Criticality analysis of a country\u2019s transport network via an agent-based supply chain model},\n  journal = {Nature Sustainability},\n  volume  = {4},\n  pages   = {209--215},\n  year    = {2021},\n  doi     = {10.1038/s41893-020-00649-4},\n  url     = {https://www.nature.com/articles/s41893-020-00649-4}\n}\n</code></pre> <pre><code>@software{disruptsc2025,\n  title={DisruptSC: Spatial Agent-Based Model for Supply Chain Disruption Analysis},\n  author={Celian Colon},\n  year={2025},\n  url={https://github.com/ccolon/disrupt-sc}\n}\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>DisruptSC is released under the MIT License.</p>"},{"location":"applications/","title":"Existing applications","text":""},{"location":"applications/#tanzania","title":"Tanzania","text":"<p>First application of the model. - Data:   - Transport: Roads only.   - Economic: GTAP to elicit the Tanzanian input--output table   - Spatial: business registry and population census, complemented with remote sensing data for agriculture - Application:   - Criticality analysis   - Analyse the impacts of disruption duration   - Assess benefits of various adaption measures: on the supply and demand side of disruption</p>"},{"location":"applications/#cambodia","title":"Cambodia","text":"<p>Second application.</p> <ul> <li>Data:</li> <li>Transport: Roads, railways, waterways, maritime.</li> <li>Economic: input--output table from Cambodian government</li> <li>Spatial: business registry, population census, complemented with remote sensing data for agriculture, fishing, and forestry</li> <li>Application:</li> <li>Criticality analysis</li> </ul>"},{"location":"applications/#ecuador","title":"Ecuador","text":"<p>Third application. - Data:   - Transport: Roads, maritime, pipelines, airways.   - Economic: input--output table from the Ecuadorian government, regional statistics, transaction data   - Spatial: business registry, population census, complemented with remote sensing data for agriculture, fishing, and oil fields - Application:   - Criticality analysis   - Assessing the impacts of floods   - Model intercomparison on the impacts of the April 2016 Earthquake</p>"},{"location":"applications/#central-asia-and-south-caucasus","title":"\ud83c\udf04 Central Asia and South Caucasus","text":"<p>Includes 8 countries: Kazakhstan, Kyrgyzstan, Uzbekistan, Tajikistan, Turkmenistan, Azerbaijan, Georgia, Armenia</p> <ul> <li>Data:</li> <li>Transport: Roads, maritime, pipelines, railways.</li> <li>Economic: multi-country input--output table derived</li> <li>Spatial: geolocalized and remote sensing data for population, agriculture, mining, electric production</li> <li>Application:</li> <li>Criticality analysis for 2023 and 2030 </li> <li>Coupling with asset exposure to floods, landslides, earthquake, heat waves</li> <li>Identification of hotspots for adaptation intervention</li> <li>Cost-benefit analysis of adaptation measures</li> </ul>"},{"location":"applications/#global","title":"\ud83c\udf0d Global","text":"<ul> <li>Data:</li> <li>Transport: Roads, maritime.</li> <li>Economic: multi-country input--output table from EORA</li> <li>Spatial: remote sensing data for population</li> <li>Application:</li> <li>Impact of global logistics disturbances</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>This section provides comprehensive technical documentation of DisruptSC's architecture, design patterns, and implementation details.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>DisruptSC is built as a modular, extensible spatial agent-based model with the following core architectural principles:</p> <ul> <li>Modular Design - Independent, replaceable components</li> <li>Spatial Modeling - Geographic awareness throughout the system</li> <li>Network-Based - Explicit modeling of relationships and infrastructure</li> <li>Data-Driven - Real-world data integration</li> <li>Disruption Analysis - Disruptions and recovery as discrete events</li> </ul>"},{"location":"architecture/#architecture-components","title":"Architecture Components","text":""},{"location":"architecture/#system-overview","title":"System Overview","text":"<p>Comprehensive overview of DisruptSC's architecture, design patterns, and component interactions. Covers the high-level system design, data flow, and integration patterns.</p> <p>Key Topics: - High-level architecture diagram - Component relationships - Data flow patterns - Design patterns (Factory, Builder, Observer) - Performance considerations - Extension points</p>"},{"location":"architecture/#agent-system","title":"Agent System","text":"<p>Detailed documentation of the agent-based modeling system, including agent types, behaviors, and interactions.</p> <p>Key Topics: - Base agent architecture - Firm agents and production modeling - Household agents and consumption patterns - Country agents and international trade - Agent interactions and relationships - Spatial agent behavior</p>"},{"location":"architecture/#network-system","title":"Network System","text":"<p>Technical details of the network modeling system, including supply chains, transport infrastructure, and economic flows.</p> <p>Key Topics: - Supply chain network structure - Transport network modeling - Multi-regional input-output networks - Network integration and flow allocation - Capacity constraints and congestion - Network disruption modeling</p>"},{"location":"architecture/#disruption-system","title":"Disruption System","text":"<p>Architecture of the flexible disruption system, supporting various disruption types and recovery mechanisms.</p> <p>Key Topics: - Disruption factory pattern - Transport disruptions - Capital destruction modeling - Supply chain disruptions - Cascading effects - Recovery mechanisms</p>"},{"location":"architecture/#simulation-engine","title":"Simulation Engine","text":"<p>Core simulation engine architecture, time management, and execution control.</p> <p>Key Topics: - Simulation controller design - Time management and scheduling - Agent decision sequencing - Market clearing mechanisms - Data collection and state management - Performance monitoring</p>"},{"location":"architecture/#core-concepts","title":"Core Concepts","text":""},{"location":"architecture/#spatial-agent-based-modeling","title":"Spatial Agent-Based Modeling","text":"<p>DisruptSC combines two powerful modeling paradigms:</p> Agent-Based Modeling (ABM) Economic agents with autonomous behaviors and interactions Spatial Modeling Agents are embedded in geographic space with transport networks <p>This combination enables realistic simulation of: - Economic decision-making by individual actors - Spatial constraints on trade and transport - Network effects and cascading disruptions - Geographic heterogeneity in impacts</p>"},{"location":"architecture/#key-components","title":"Key Components","text":"<pre><code>graph TD\n    A[Transport Network] --&gt; B[Agent Location]\n    B --&gt; C[Supply Chain Network]\n    C --&gt; D[Economic Equilibrium]\n    D --&gt; E[Disruption Scenarios]\n    E --&gt; F[Dynamic Simulation]\n    F --&gt; G[Impact Analysis]</code></pre>"},{"location":"architecture/#agent-types","title":"Agent Types","text":"<p>DisruptSC models three types of economic agents:</p>"},{"location":"architecture/#firms","title":"\ud83c\udfed Firms","text":"<ul> <li>Role: Producers of goods and services</li> <li>Behavior: Production planning, supplier selection, inventory management</li> <li>Location: Spatially distributed based on economic data</li> <li>Key Attributes: Sector, production capacity, input requirements</li> </ul>"},{"location":"architecture/#households","title":"\ud83c\udfe0 Households","text":"<ul> <li>Role: Final consumers of goods and services</li> <li>Behavior: Consumption demand, retailer selection</li> <li>Location: Population-weighted spatial distribution</li> <li>Key Attributes: Region, consumption patterns, size</li> </ul>"},{"location":"architecture/#countries","title":"\ud83c\udf0d Countries","text":"<ul> <li>Role: International trade partners</li> <li>Behavior: Imports and exports goods and services</li> <li>Location: Border points</li> <li>Key Attributes: Trade shares</li> </ul>"},{"location":"architecture/#network-structures","title":"Network Structures","text":""},{"location":"architecture/#transport-networks","title":"Transport Networks","text":"<p>Multi-modal infrastructure with :</p> <ul> <li>Roads - Primary domestic transport</li> <li>Maritime - International transport  </li> <li>Railways - Freight corridors</li> <li>Airways - High-value goods or distant islands</li> <li>Waterways - River and canal transport</li> <li>Pipelines - Oil and gas</li> </ul>"},{"location":"architecture/#supply-chain-networks","title":"Supply Chain Networks","text":"<p>Commercial relationships between agents: - B2B Links - Firm-to-firm - B2C Links - Firm-to-household - Imports/Exports - Country-to-firm, country-to-household, firm-to-country - Transit - Country-to-country</p>"},{"location":"architecture/#model-workflow","title":"Model Workflow","text":""},{"location":"architecture/#initialization-phase","title":"Initialization Phase","text":"<ol> <li>Transport Network Setup</li> <li>Load infrastructure data</li> <li>Build network graph</li> <li> <p>Configure logistics parameters</p> </li> <li> <p>Agent Creation</p> </li> <li>Generate firms from economic data</li> <li>Place households by population</li> <li> <p>Position countries at borders</p> </li> <li> <p>Supply Chain Formation</p> </li> <li>Link buyers and suppliers</li> <li>Assign commercial relationships</li> <li> <p>Configure trade parameters</p> </li> <li> <p>Logistic Routes Identification</p> </li> <li>Find lower-cost transport paths from suppliers to clients</li> <li> <p>Assign transport costs to firms</p> </li> <li> <p>Initial Economic Equilibrium</p> </li> <li>Calculate production levels</li> <li>Set prices and flows</li> <li>Initialize inventories</li> </ol>"},{"location":"architecture/#simulation-phase","title":"Simulation Phase","text":"<ol> <li>Disruption Scenario</li> <li>Schedule disruption: transport, capital, productivity</li> <li> <p>Trigger disruption and recovery processes</p> </li> <li> <p>Dynamic Simulation</p> </li> <li>Logistic adaptation via rerouting</li> <li>Cost-push price adjustment </li> <li>Commercial adaptation: change of suppliers</li> <li> <p>Impact propagation</p> </li> <li> <p>Impact Analysis</p> </li> <li>Agent state tracking</li> <li>Flow monitoring</li> <li>Performance metrics</li> </ol>"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#parsimonious","title":"Parsimonious","text":""},{"location":"architecture/#_1","title":"Architecture","text":""},{"location":"architecture/#modular-and-extensible","title":"Modular and extensible","text":"<ul> <li>Clear separation of concerns</li> <li>Pluggable component architecture</li> <li>Flexible configuration system</li> <li></li> </ul>"},{"location":"architecture/#extensibility","title":"Extensibility","text":"<ul> <li>Abstract base classes for new agent types</li> <li>Plugin system for disruption types</li> <li>Configurable economic behaviors</li> </ul>"},{"location":"architecture/#realism","title":"Realism","text":"<ul> <li>Based on economic theory (Input-Output)</li> <li>Realistic transport costs and times</li> <li>Empirically-calibrated parameters</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<pre><code>graph LR\n    A[Input Data] --&gt; B[Model Initialization]\n    B --&gt; C[Economic Equilibrium]\n    C --&gt; D[Disruption Scenarios]\n    D --&gt; E[Time-Step Simulation]\n    E --&gt; F[Output Analysis]\n\n    A1[MRIO Tables] --&gt; A\n    A2[Transport Networks] --&gt; A\n    A3[Spatial Data] --&gt; A\n\n    F --&gt; F1[Economic Impacts]\n    F --&gt; F2[Spatial Results]\n    F --&gt; F3[Network Flows]</code></pre>"},{"location":"architecture/#performance","title":"Performance","text":""},{"location":"architecture/#computational-complexity","title":"Computational Complexity","text":"<ul> <li>Shortest path algorithm is for initial route selection and rerouting is most computationally intensive</li> <li>Scales with number of agents and number of linkages, linear in simulation duration</li> </ul>"},{"location":"architecture/#memory-requirements","title":"Memory Requirements","text":"<ul> <li>Minimum: 8GB RAM for small models</li> <li>Recommended: 16GB+</li> </ul>"},{"location":"architecture/#runtime-performance","title":"Runtime Performance","text":"<ul> <li>Initialization: Seconds to minutes, depending on scale</li> <li>Simulation: Seconds for undisrupted time steps, minutes for disrupted time steps</li> </ul>"},{"location":"architecture/#how-to-speed-up","title":"How to speed-up","text":"<ul> <li>Cut off small agents and commercial relationship</li> <li>Cache routes and initial states</li> <li>Parallelize: not yet implemented</li> </ul>"},{"location":"architecture/#technology-stack","title":"Technology Stack","text":""},{"location":"architecture/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>Python 3.10+ - Primary language</li> <li>NetworkX - Graph algorithms</li> <li>Pandas/NumPy - Data processing</li> <li>GeoPandas - Spatial data handling</li> <li>SciPy - Scientific computing</li> </ul>"},{"location":"architecture/#optional-components","title":"Optional Components","text":"<ul> <li>Matplotlib/Plotly - Visualization</li> <li>Jupyter - Interactive analysis</li> <li>Dask - Parallel computing</li> <li>PostGIS - Spatial databases</li> </ul>"},{"location":"architecture/#extension-points","title":"Extension Points","text":""},{"location":"architecture/#custom-agent-types","title":"Custom Agent Types","text":"<pre><code>from disruptsc.agents.base_agent import BaseAgent\n\nclass CustomAgent(BaseAgent):\n    def __init__(self, ...):\n        # Custom initialization\n        pass\n\n    def custom_behavior(self):\n        # Agent-specific logic\n        pass\n</code></pre>"},{"location":"architecture/#custom-disruption-types","title":"Custom Disruption Types","text":"<pre><code>from disruptsc.disruption.disruption import BaseDisruption\n\nclass CustomDisruption(BaseDisruption):\n    def apply(self, model, time_step):\n        # Disruption logic\n        pass\n</code></pre>"},{"location":"architecture/#whats-next","title":"What's Next?","text":"<p>Explore the detailed architecture:</p> <ul> <li>Agents - Economic actors and their behaviors</li> <li>Networks - Transport and supply chain structures</li> <li>Disruptions - Event modeling and recovery</li> <li>Simulation - Time-stepped execution and data collection</li> </ul>"},{"location":"architecture/agents/","title":"Agent System","text":"<p>The agent system is the core of DisruptSC's economic modeling, representing firms, households, and countries as autonomous decision-making entities with spatial awareness and adaptive behaviors.</p>"},{"location":"architecture/agents/#agent-architecture","title":"Agent Architecture","text":""},{"location":"architecture/agents/#base-agent-class","title":"Base Agent Class","text":"<p>All agents inherit from <code>BaseAgent</code>, providing common functionality:</p> <pre><code>class BaseAgent:\n    \"\"\"Base class for all economic agents.\"\"\"\n\n    def __init__(self, pid, coordinate, region):\n        self.pid = pid                    # Unique identifier\n        self.coordinate = coordinate      # Geographic location (Point)\n        self.region = region             # Administrative region\n        self.neighbors = []              # Spatial neighbors\n        self.active = True               # Agent status\n\n    def update(self, t, **kwargs):\n        \"\"\"Update agent state at time t.\"\"\"\n        pass\n\n    def reset(self):\n        \"\"\"Reset agent to initial state.\"\"\"\n        pass\n</code></pre>"},{"location":"architecture/agents/#agent-types-overview","title":"Agent Types Overview","text":"<pre><code>classDiagram\n    class BaseAgent {\n        +pid: str\n        +coordinate: Point\n        +region: str\n        +neighbors: list\n        +update(t)\n        +reset()\n    }\n\n    class Firm {\n        +sector: str\n        +production_target: float\n        +inventory: dict\n        +suppliers: dict\n        +customers: dict\n        +produce()\n        +purchase()\n        +sell()\n    }\n\n    class Household {\n        +population: int\n        +consumption_budget: float\n        +consumption_targets: dict\n        +consume()\n        +update_demand()\n    }\n\n    class Country {\n        +country_code: str\n        +trade_flows: dict\n        +border_capacity: float\n        +export()\n        +import()\n    }\n\n    BaseAgent &lt;|-- Firm\n    BaseAgent &lt;|-- Household\n    BaseAgent &lt;|-- Country</code></pre>"},{"location":"architecture/agents/#firm-agents","title":"Firm Agents","text":"<p>Firms are the primary production agents in the model, representing businesses across different sectors.</p>"},{"location":"architecture/agents/#firm-attributes","title":"Firm Attributes","text":"Attribute Type Description <code>sector</code> string Region-sector code (e.g., \"AGR_KHM\") <code>production_target</code> float Planned output for current period <code>production_current</code> float Actual production achieved <code>utilization_rate</code> float Capacity utilization (0-1) <code>inventory</code> dict Input inventories by product type <code>product_stock</code> float Finished goods inventory <code>purchase_plan</code> dict Planned purchases from suppliers <code>suppliers</code> dict Supplier relationships and weights <code>customers</code> dict Customer relationships <code>finance</code> float Financial position"},{"location":"architecture/agents/#firm-behavior","title":"Firm Behavior","text":""},{"location":"architecture/agents/#production-process","title":"Production Process","text":"<pre><code>sequenceDiagram\n    participant F as Firm\n    participant S as Suppliers\n    participant I as Inventory\n    participant P as Production\n\n    F-&gt;&gt;F: Set production target\n    F-&gt;&gt;I: Check input availability\n    F-&gt;&gt;S: Place purchase orders\n    S-&gt;&gt;F: Deliver inputs\n    F-&gt;&gt;I: Update inventory\n    F-&gt;&gt;P: Execute production\n    P-&gt;&gt;F: Output products\n    F-&gt;&gt;F: Update stock levels</code></pre>"},{"location":"architecture/agents/#decision-making","title":"Decision Making","text":"<p>Firms make several key decisions each time step:</p> <ol> <li> <p>Production Planning <pre><code>def set_production_target(self, t):\n    # Base on demand forecasts and inventory levels\n    target_demand = self.forecast_demand()\n    inventory_adjustment = self.calculate_inventory_gap()\n    self.production_target = target_demand + inventory_adjustment\n</code></pre></p> </li> <li> <p>Supplier Selection <pre><code>def select_suppliers(self):\n    # Choose suppliers based on:\n    # - Price competitiveness\n    # - Geographic proximity  \n    # - Reliability/relationship strength\n    # - Inventory levels\n    pass\n</code></pre></p> </li> <li> <p>Inventory Management <pre><code>def manage_inventory(self):\n    # Maintain target inventory levels\n    # Adjust for demand variability\n    # Account for supply chain reliability\n    pass\n</code></pre></p> </li> </ol>"},{"location":"architecture/agents/#firm-types-by-sector","title":"Firm Types by Sector","text":""},{"location":"architecture/agents/#agricultural-firms","title":"Agricultural Firms","text":"<ul> <li>Characteristics: Seasonal production, weather sensitivity, bulk products</li> <li>Behavior: Storage management, harvest timing, price volatility adaptation</li> <li>Transport: High volume, low value, time-sensitive for perishables</li> </ul>"},{"location":"architecture/agents/#manufacturing-firms","title":"Manufacturing Firms","text":"<ul> <li>Characteristics: Complex supply chains, intermediate goods, scale economies</li> <li>Behavior: Just-in-time inventory, supplier diversification, quality control</li> <li>Transport: Container shipping, rail freight, supply chain coordination</li> </ul>"},{"location":"architecture/agents/#service-firms","title":"Service Firms","text":"<ul> <li>Characteristics: Labor-intensive, local markets, information flows</li> <li>Behavior: Demand responsiveness, location optimization, network effects</li> <li>Transport: Minimal physical goods, people movement, digital services</li> </ul>"},{"location":"architecture/agents/#firm-component-classes","title":"Firm Component Classes","text":""},{"location":"architecture/agents/#inventory-management-firminventorymixin","title":"Inventory Management (<code>FirmInventoryMixin</code>)","text":"<pre><code>class FirmInventoryMixin:\n    def __init__(self):\n        self.inventory_targets = {}      # Target levels by product\n        self.inventory_current = {}      # Current levels\n        self.inventory_costs = {}        # Holding costs\n\n    def calculate_inventory_gap(self, product):\n        \"\"\"Calculate difference between target and current inventory.\"\"\"\n        target = self.inventory_targets.get(product, 0)\n        current = self.inventory_current.get(product, 0)\n        return max(0, target - current)\n\n    def update_inventory_targets(self):\n        \"\"\"Adaptively adjust inventory targets based on experience.\"\"\"\n        for product in self.inventory_targets:\n            # Increase targets if frequently stocked out\n            # Decrease targets if holding excess inventory\n            pass\n</code></pre>"},{"location":"architecture/agents/#financial-management-firmfinancemixin","title":"Financial Management (<code>FirmFinanceMixin</code>)","text":"<pre><code>class FirmFinanceMixin:\n    def __init__(self):\n        self.revenue = 0\n        self.costs = 0\n        self.profit = 0\n        self.cash_flow = 0\n\n    def calculate_profitability(self):\n        \"\"\"Calculate current period profit/loss.\"\"\"\n        self.profit = self.revenue - self.costs\n        self.cash_flow += self.profit\n\n    def can_afford_purchases(self, purchase_value):\n        \"\"\"Check if firm can afford planned purchases.\"\"\"\n        return self.cash_flow &gt;= purchase_value\n</code></pre>"},{"location":"architecture/agents/#transport-integration-transportmixin","title":"Transport Integration (<code>TransportMixin</code>)","text":"<pre><code>class TransportMixin:\n    def __init__(self):\n        self.transport_costs = {}\n        self.preferred_routes = {}\n        self.shipments = []\n\n    def select_transport_mode(self, destination, product, volume):\n        \"\"\"Choose optimal transport mode based on cost and time.\"\"\"\n        # Consider:\n        # - Product characteristics (bulk, value, urgency)\n        # - Distance and available modes\n        # - Cost vs time trade-offs\n        pass\n\n    def schedule_shipments(self):\n        \"\"\"Optimize shipment scheduling and consolidation.\"\"\"\n        pass\n</code></pre>"},{"location":"architecture/agents/#household-agents","title":"Household Agents","text":"<p>Households represent final consumers and provide demand for the economic system.</p>"},{"location":"architecture/agents/#household-attributes","title":"Household Attributes","text":"Attribute Type Description <code>population</code> int Number of people represented <code>consumption_budget</code> float Total spending capacity <code>consumption_targets</code> dict Desired consumption by sector <code>consumption_actual</code> dict Actual consumption achieved <code>consumption_loss</code> dict Unmet demand by sector <code>suppliers</code> dict Retailer relationships"},{"location":"architecture/agents/#household-behavior","title":"Household Behavior","text":""},{"location":"architecture/agents/#consumption-process","title":"Consumption Process","text":"<pre><code>flowchart TD\n    A[Determine Budget] --&gt; B[Set Consumption Targets]\n    B --&gt; C[Contact Suppliers]\n    C --&gt; D[Check Availability]\n    D --&gt; E{Goods Available?}\n    E --&gt;|Yes| F[Purchase Goods]\n    E --&gt;|No| G[Record Unmet Demand]\n    F --&gt; H[Consume Goods]\n    G --&gt; I[Adjust Future Behavior]\n    H --&gt; J[Update Satisfaction]\n    I --&gt; J</code></pre>"},{"location":"architecture/agents/#demand-formation","title":"Demand Formation","text":"<p>Households determine consumption based on:</p> <ol> <li> <p>Budget Constraints <pre><code>def allocate_budget(self):\n    # Distribute budget across sectors\n    # Based on preferences and necessities\n    total_budget = self.consumption_budget\n    for sector in self.consumption_targets:\n        share = self.consumption_shares[sector]\n        self.sector_budgets[sector] = total_budget * share\n</code></pre></p> </li> <li> <p>Price Sensitivity <pre><code>def adjust_for_prices(self, sector, price):\n    # Reduce demand if prices increase\n    elasticity = self.price_elasticities[sector]\n    price_change = (price - self.reference_prices[sector]) / self.reference_prices[sector]\n    demand_change = -elasticity * price_change\n    self.consumption_targets[sector] *= (1 + demand_change)\n</code></pre></p> </li> <li> <p>Availability Constraints <pre><code>def handle_shortages(self, sector, available_quantity):\n    # Record unmet demand\n    # Consider substitution possibilities\n    demanded = self.consumption_targets[sector]\n    shortfall = max(0, demanded - available_quantity)\n    self.consumption_loss[sector] = shortfall\n</code></pre></p> </li> </ol>"},{"location":"architecture/agents/#household-types","title":"Household Types","text":""},{"location":"architecture/agents/#urban-households","title":"Urban Households","text":"<ul> <li>Characteristics: Higher incomes, diverse consumption, service-oriented</li> <li>Behavior: Quality sensitivity, brand preferences, convenience focus</li> <li>Location: City centers, good transport access</li> </ul>"},{"location":"architecture/agents/#rural-households","title":"Rural Households","text":"<ul> <li>Characteristics: Lower incomes, subsistence elements, local markets</li> <li>Behavior: Price sensitivity, local sourcing, seasonal patterns</li> <li>Location: Agricultural areas, limited transport access</li> </ul>"},{"location":"architecture/agents/#household-spatial-behavior","title":"Household Spatial Behavior","text":"<p>Households interact with nearby suppliers based on:</p> <ul> <li>Geographic proximity - Travel costs and convenience</li> <li>Market accessibility - Transport infrastructure quality</li> <li>Supplier diversity - Number and type of local retailers</li> <li>Income levels - Ability to travel for better options</li> </ul>"},{"location":"architecture/agents/#country-agents","title":"Country Agents","text":"<p>Countries represent international trade partners and border/port entry points.</p>"},{"location":"architecture/agents/#country-attributes","title":"Country Attributes","text":"Attribute Type Description <code>country_code</code> string ISO country code (e.g., \"CHN\", \"THA\") <code>import_flows</code> dict Goods imported by sector <code>export_flows</code> dict Goods exported by sector <code>border_capacity</code> float Trade processing capacity <code>trade_costs</code> dict Import/export costs by mode"},{"location":"architecture/agents/#country-behavior","title":"Country Behavior","text":""},{"location":"architecture/agents/#trade-flow-management","title":"Trade Flow Management","text":"<pre><code>class Country(BaseAgent):\n    def process_imports(self, t):\n        \"\"\"Process incoming import orders.\"\"\"\n        for sector, orders in self.pending_imports.items():\n            # Apply trade policies and restrictions\n            # Calculate tariffs and processing costs\n            # Schedule deliveries based on capacity\n            pass\n\n    def generate_exports(self, t):\n        \"\"\"Generate export supply based on external demand.\"\"\"\n        for sector in self.export_sectors:\n            # External demand (outside model scope)\n            # Production capacity in source country\n            # Trade agreements and policies\n            pass\n</code></pre>"},{"location":"architecture/agents/#border-processing","title":"Border Processing","text":"<p>Countries model border crossing and port operations:</p> <ul> <li>Capacity constraints - Limited processing throughput</li> <li>Processing times - Customs, inspection, documentation</li> <li>Infrastructure quality - Port efficiency, border facilities</li> <li>Policy impacts - Tariffs, quotas, trade agreements</li> </ul>"},{"location":"architecture/agents/#agent-interactions","title":"Agent Interactions","text":""},{"location":"architecture/agents/#supplier-buyer-relationships","title":"Supplier-Buyer Relationships","text":"<pre><code>graph LR\n    F1[Firm 1] --&gt;|Supplies| F2[Firm 2]\n    F2 --&gt;|Supplies| F3[Firm 3]\n    F3 --&gt;|Supplies| H[Household]\n    C[Country] --&gt;|Imports| F2\n    F1 --&gt;|Exports| C\n\n    subgraph \"Domestic Supply Chain\"\n        F1\n        F2\n        F3\n    end</code></pre>"},{"location":"architecture/agents/#relationship-formation","title":"Relationship Formation","text":"<p>Agents form relationships based on:</p> <ol> <li>Geographic proximity - Reduced transport costs</li> <li>Economic compatibility - Sector input-output relationships</li> <li>Reliability - Past performance and relationship strength</li> <li>Price competitiveness - Cost considerations</li> <li>Capacity matching - Supplier capacity vs buyer needs</li> </ol>"},{"location":"architecture/agents/#adaptive-behavior","title":"Adaptive Behavior","text":"<p>Agents learn and adapt over time:</p>"},{"location":"architecture/agents/#supplier-relationship-updates","title":"Supplier Relationship Updates","text":"<pre><code>def update_supplier_weights(self, supplier_id, performance):\n    \"\"\"Adjust supplier relationship strength based on performance.\"\"\"\n    current_weight = self.suppliers[supplier_id]\n\n    if performance &gt; threshold:\n        # Strengthen relationship\n        new_weight = min(1.0, current_weight * 1.1)\n    else:\n        # Weaken relationship\n        new_weight = max(0.1, current_weight * 0.9)\n\n    self.suppliers[supplier_id] = new_weight\n</code></pre>"},{"location":"architecture/agents/#inventory-target-adjustment","title":"Inventory Target Adjustment","text":"<pre><code>def adapt_inventory_targets(self):\n    \"\"\"Adjust inventory targets based on recent stockout experience.\"\"\"\n    for product in self.inventory_targets:\n        stockout_rate = self.calculate_stockout_rate(product)\n\n        if stockout_rate &gt; acceptable_threshold:\n            # Increase inventory target\n            self.inventory_targets[product] *= 1.2\n        elif stockout_rate == 0:\n            # Decrease inventory target\n            self.inventory_targets[product] *= 0.95\n</code></pre>"},{"location":"architecture/agents/#agent-collections-and-management","title":"Agent Collections and Management","text":""},{"location":"architecture/agents/#agent-containers","title":"Agent Containers","text":"<p>Agents are organized in specialized container classes:</p> <pre><code>class Firms:\n    \"\"\"Container for all firm agents.\"\"\"\n    def __init__(self):\n        self.firms = {}              # pid -&gt; Firm mapping\n        self.by_sector = {}          # sector -&gt; [firms] mapping\n        self.by_region = {}          # region -&gt; [firms] mapping\n\n    def update_all(self, t):\n        \"\"\"Update all firms in parallel.\"\"\"\n        for firm in self.firms.values():\n            firm.update(t)\n\n    def get_by_sector(self, sector):\n        \"\"\"Get all firms in a specific sector.\"\"\"\n        return self.by_sector.get(sector, [])\n</code></pre>"},{"location":"architecture/agents/#spatial-agent-queries","title":"Spatial Agent Queries","text":"<p>Agents support spatial queries for efficient neighbor finding:</p> <pre><code>class SpatialAgentIndex:\n    \"\"\"Spatial index for efficient agent queries.\"\"\"\n\n    def __init__(self, agents):\n        self.agents = agents\n        self.spatial_index = self._build_spatial_index()\n\n    def find_neighbors(self, agent, radius):\n        \"\"\"Find all agents within radius of given agent.\"\"\"\n        point = agent.coordinate\n        candidates = self.spatial_index.intersection(\n            point.buffer(radius).bounds\n        )\n        return [self.agents[idx] for idx in candidates]\n\n    def nearest_agents(self, agent, n=5, agent_type=None):\n        \"\"\"Find n nearest agents of specified type.\"\"\"\n        distances = []\n        for other in self.agents.values():\n            if agent_type and not isinstance(other, agent_type):\n                continue\n            dist = agent.coordinate.distance(other.coordinate)\n            distances.append((dist, other))\n\n        distances.sort()\n        return [agent for dist, agent in distances[:n]]\n</code></pre>"},{"location":"architecture/agents/#performance-optimization","title":"Performance Optimization","text":""},{"location":"architecture/agents/#agent-update-strategies","title":"Agent Update Strategies","text":"<ol> <li>Parallel Updates - Independent agents updated simultaneously</li> <li>Batch Processing - Group similar operations</li> <li>Lazy Evaluation - Compute only when needed</li> <li>State Caching - Cache expensive calculations</li> </ol>"},{"location":"architecture/agents/#memory-management","title":"Memory Management","text":"<pre><code>class MemoryEfficientAgent:\n    \"\"\"Base class with memory optimization.\"\"\"\n\n    __slots__ = ['pid', 'coordinate', 'region', '_cache']\n\n    def __init__(self, pid, coordinate, region):\n        self.pid = pid\n        self.coordinate = coordinate\n        self.region = region\n        self._cache = {}\n\n    def clear_cache(self):\n        \"\"\"Clear cached calculations to free memory.\"\"\"\n        self._cache.clear()\n</code></pre>"},{"location":"architecture/agents/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"architecture/agents/#agent-behavior-tests","title":"Agent Behavior Tests","text":"<pre><code>def test_firm_production():\n    \"\"\"Test firm production logic.\"\"\"\n    firm = Firm(pid=\"test_firm\", sector=\"MAN_TEST\")\n\n    # Set up initial conditions\n    firm.production_target = 1000\n    firm.inventory = {\"input_1\": 500, \"input_2\": 300}\n\n    # Execute production\n    firm.produce()\n\n    # Validate results\n    assert firm.product_stock &gt; 0\n    assert firm.inventory[\"input_1\"] &lt; 500  # Inputs consumed\n</code></pre>"},{"location":"architecture/agents/#integration-tests","title":"Integration Tests","text":"<pre><code>def test_supply_chain_interaction():\n    \"\"\"Test interaction between supplier and buyer.\"\"\"\n    supplier = Firm(pid=\"supplier\", sector=\"AGR_TEST\")\n    buyer = Firm(pid=\"buyer\", sector=\"MAN_TEST\")\n\n    # Set up relationship\n    buyer.add_supplier(supplier, product=\"AGR_TEST\", weight=1.0)\n\n    # Execute transaction\n    buyer.place_order(supplier, product=\"AGR_TEST\", quantity=100)\n    supplier.fulfill_order(buyer, quantity=100)\n\n    # Validate transaction\n    assert buyer.inventory[\"AGR_TEST\"] == 100\n    assert supplier.product_stock &lt; initial_stock\n</code></pre>"},{"location":"architecture/agents/#future-enhancements","title":"Future Enhancements","text":""},{"location":"architecture/agents/#planned-agent-features","title":"Planned Agent Features","text":"<ol> <li>Learning Algorithms - Machine learning for agent behavior</li> <li>Social Networks - Agent-to-agent information flows</li> <li>Heterogeneous Agents - More diverse agent types and behaviors</li> <li>Dynamic Agent Creation - Firm entry/exit during simulation</li> </ol>"},{"location":"architecture/agents/#advanced-behaviors","title":"Advanced Behaviors","text":"<ol> <li>Strategic Planning - Multi-period optimization</li> <li>Risk Management - Uncertainty handling and hedging</li> <li>Innovation - Technology adoption and productivity growth</li> <li>Market Power - Monopolistic and oligopolistic behaviors</li> </ol>"},{"location":"architecture/disruptions/","title":"Disruption System","text":"<p>The disruption system is designed to model various types of supply chain disruptions and their cascading effects through the economic and transport networks. This system uses a flexible factory pattern to support different disruption types and recovery mechanisms.</p>"},{"location":"architecture/disruptions/#disruption-architecture","title":"Disruption Architecture","text":""},{"location":"architecture/disruptions/#core-components","title":"Core Components","text":"<pre><code>classDiagram\n    class DisruptionFactory {\n        +registered_types: dict\n        +create_disruption(config, context)\n        +register_type(name, creator)\n    }\n\n    class DisruptionContext {\n        +agents: AgentCollection\n        +networks: NetworkCollection\n        +parameters: Parameters\n        +current_time: int\n    }\n\n    class BaseDisruption {\n        +start_time: int\n        +duration: int\n        +severity: float\n        +apply(context)\n        +remove(context)\n        +is_active(t)\n    }\n\n    class DisruptionList {\n        +disruptions: list\n        +add_disruption(disruption)\n        +update(t, context)\n        +get_active_disruptions(t)\n    }\n\n    DisruptionFactory --&gt; BaseDisruption\n    DisruptionFactory --&gt; DisruptionContext\n    DisruptionList --&gt; BaseDisruption</code></pre>"},{"location":"architecture/disruptions/#factory-pattern-implementation","title":"Factory Pattern Implementation","text":"<pre><code>class DisruptionFactory:\n    \"\"\"Factory for creating disruptions from configuration.\"\"\"\n\n    _registered_types = {}\n\n    @classmethod\n    def register_disruption_type(cls, name: str, creator_func):\n        \"\"\"Register a new disruption type.\"\"\"\n        cls._registered_types[name] = creator_func\n\n    @classmethod\n    def create_disruption(cls, config: dict, context: DisruptionContext):\n        \"\"\"Create disruption from configuration.\"\"\"\n        disruption_type = config.get('type')\n\n        if disruption_type not in cls._registered_types:\n            raise ValueError(f\"Unknown disruption type: {disruption_type}\")\n\n        creator = cls._registered_types[disruption_type]\n        return creator(config, context)\n\n    @classmethod\n    def list_available_types(cls):\n        \"\"\"List all registered disruption types.\"\"\"\n        return list(cls._registered_types.keys())\n</code></pre>"},{"location":"architecture/disruptions/#base-disruption-class","title":"Base Disruption Class","text":"<p>All disruptions inherit from the <code>BaseDisruption</code> class:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass BaseDisruption(ABC):\n    \"\"\"Abstract base class for all disruption types.\"\"\"\n\n    def __init__(self, start_time: int, duration: int = None, **kwargs):\n        self.start_time = start_time\n        self.duration = duration  # None = permanent\n        self.severity = kwargs.get('severity', 1.0)\n        self.description = kwargs.get('description', '')\n        self.affected_entities = set()\n        self.original_states = {}  # Store original values for recovery\n\n    def is_active(self, t: int) -&gt; bool:\n        \"\"\"Check if disruption is active at time t.\"\"\"\n        if t &lt; self.start_time:\n            return False\n        if self.duration is None:\n            return True\n        return t &lt; (self.start_time + self.duration)\n\n    @abstractmethod\n    def apply(self, context: DisruptionContext):\n        \"\"\"Apply disruption effects.\"\"\"\n        pass\n\n    @abstractmethod\n    def remove(self, context: DisruptionContext):\n        \"\"\"Remove disruption effects (for recovery).\"\"\"\n        pass\n\n    def get_severity_at_time(self, t: int) -&gt; float:\n        \"\"\"Get disruption severity at specific time (can vary over time).\"\"\"\n        if not self.is_active(t):\n            return 0.0\n        return self.severity\n</code></pre>"},{"location":"architecture/disruptions/#transport-disruptions","title":"Transport Disruptions","text":"<p>Transport disruptions affect the physical movement of goods through the transport network.</p>"},{"location":"architecture/disruptions/#edge-based-transport-disruption","title":"Edge-Based Transport Disruption","text":"<pre><code>class TransportDisruption(BaseDisruption):\n    \"\"\"Disruption affecting transport network edges.\"\"\"\n\n    def __init__(self, start_time: int, affected_edges: list, **kwargs):\n        super().__init__(start_time, **kwargs)\n        self.affected_edges = affected_edges\n        self.capacity_reduction = kwargs.get('capacity_reduction', 1.0)\n        self.speed_reduction = kwargs.get('speed_reduction', 0.5)\n\n    def apply(self, context: DisruptionContext):\n        \"\"\"Apply transport disruption to network edges.\"\"\"\n        transport_network = context.networks.transport_network\n\n        for edge_id in self.affected_edges:\n            # Find edge in network\n            edge_data = self._find_edge(transport_network, edge_id)\n\n            if edge_data:\n                # Store original values\n                original_capacity = edge_data.get('capacity', float('inf'))\n                original_speed = edge_data.get('max_speed', 50)\n\n                self.original_states[edge_id] = {\n                    'capacity': original_capacity,\n                    'max_speed': original_speed\n                }\n\n                # Apply disruption\n                new_capacity = original_capacity * (1 - self.capacity_reduction)\n                new_speed = original_speed * (1 - self.speed_reduction)\n\n                edge_data['capacity'] = max(0, new_capacity)\n                edge_data['max_speed'] = max(1, new_speed)\n                edge_data['disrupted'] = True\n\n                self.affected_entities.add(edge_id)\n\n    def remove(self, context: DisruptionContext):\n        \"\"\"Remove transport disruption (recovery).\"\"\"\n        transport_network = context.networks.transport_network\n\n        for edge_id in self.affected_entities:\n            edge_data = self._find_edge(transport_network, edge_id)\n\n            if edge_data and edge_id in self.original_states:\n                # Restore original values\n                original = self.original_states[edge_id]\n                edge_data['capacity'] = original['capacity']\n                edge_data['max_speed'] = original['max_speed']\n                edge_data['disrupted'] = False\n</code></pre>"},{"location":"architecture/disruptions/#attribute-based-transport-disruption","title":"Attribute-Based Transport Disruption","text":"<pre><code>def create_attribute_transport_disruption(config: dict, context: DisruptionContext):\n    \"\"\"Create transport disruption based on edge attributes.\"\"\"\n\n    attribute = config['attribute']\n    values = config['value'] if isinstance(config['value'], list) else [config['value']]\n\n    # Find all edges matching the attribute criteria\n    affected_edges = []\n    transport_network = context.networks.transport_network\n\n    for u, v, data in transport_network.edges(data=True):\n        edge_attr_value = data.get(attribute)\n        if edge_attr_value in values:\n            affected_edges.append((u, v))\n\n    return TransportDisruption(\n        start_time=config['start_time'],\n        duration=config.get('duration'),\n        affected_edges=affected_edges,\n        capacity_reduction=config.get('capacity_reduction', 1.0),\n        speed_reduction=config.get('speed_reduction', 0.5)\n    )\n\n# Register the creator function\nDisruptionFactory.register_disruption_type(\n    'transport_disruption', \n    create_attribute_transport_disruption\n)\n</code></pre>"},{"location":"architecture/disruptions/#capital-destruction-disruptions","title":"Capital Destruction Disruptions","text":"<p>Capital destruction disruptions damage productive capacity of firms.</p>"},{"location":"architecture/disruptions/#firm-capital-destruction","title":"Firm Capital Destruction","text":"<pre><code>class CapitalDestruction(BaseDisruption):\n    \"\"\"Disruption destroying firm production capacity.\"\"\"\n\n    def __init__(self, start_time: int, damage_data: dict, **kwargs):\n        super().__init__(start_time, **kwargs)\n        self.damage_data = damage_data  # {firm_id: damage_amount}\n        self.reconstruction_rate = kwargs.get('reconstruction_rate', 0.1)\n        self.reconstruction_market = kwargs.get('reconstruction_market', False)\n\n    def apply(self, context: DisruptionContext):\n        \"\"\"Apply capital destruction to firms.\"\"\"\n\n        for firm_id, damage_amount in self.damage_data.items():\n            firm = context.agents.firms.get(firm_id)\n\n            if firm:\n                # Store original capacity\n                original_capacity = firm.production_capacity\n                self.original_states[firm_id] = {\n                    'production_capacity': original_capacity\n                }\n\n                # Apply damage\n                capacity_loss = damage_amount / firm.capital_value\n                new_capacity = original_capacity * (1 - capacity_loss)\n                firm.production_capacity = max(0, new_capacity)\n                firm.capital_damaged = damage_amount\n\n                self.affected_entities.add(firm_id)\n\n                # Add to reconstruction demand if enabled\n                if self.reconstruction_market:\n                    self._add_reconstruction_demand(firm, damage_amount, context)\n\n    def _add_reconstruction_demand(self, firm, damage_amount, context):\n        \"\"\"Add reconstruction demand to the economy.\"\"\"\n\n        # Create reconstruction agent or add demand to existing construction sector\n        construction_demand = {\n            'requester': firm.pid,\n            'amount': damage_amount,\n            'timeline': int(damage_amount / (firm.production_capacity * self.reconstruction_rate)),\n            'priority': 'high'\n        }\n\n        context.reconstruction_queue.append(construction_demand)\n</code></pre>"},{"location":"architecture/disruptions/#regional-capital-destruction","title":"Regional Capital Destruction","text":"<pre><code>def create_regional_capital_destruction(config: dict, context: DisruptionContext):\n    \"\"\"Create capital destruction from regional damage file.\"\"\"\n\n    damage_file = config['region_sector_filepath']\n    damage_data = pd.read_csv(damage_file)\n\n    firm_damage = {}\n\n    for _, row in damage_data.iterrows():\n        region_sector = row['region_sector']\n        damage_amount = row['capital_destroyed']\n\n        # Find firms in this region-sector\n        affected_firms = context.agents.firms.get_by_sector(region_sector)\n\n        # Distribute damage among firms (proportional to size)\n        total_capacity = sum(firm.production_capacity for firm in affected_firms)\n\n        for firm in affected_firms:\n            if total_capacity &gt; 0:\n                firm_share = firm.production_capacity / total_capacity\n                firm_damage[firm.pid] = damage_amount * firm_share\n\n    return CapitalDestruction(\n        start_time=config['start_time'],\n        damage_data=firm_damage,\n        reconstruction_rate=config.get('reconstruction_rate', 0.1),\n        reconstruction_market=config.get('reconstruction_market', False)\n    )\n\nDisruptionFactory.register_disruption_type(\n    'capital_destruction',\n    create_regional_capital_destruction\n)\n</code></pre>"},{"location":"architecture/disruptions/#supply-chain-disruptions","title":"Supply Chain Disruptions","text":"<p>Supply chain disruptions affect commercial relationships between agents.</p>"},{"location":"architecture/disruptions/#supplier-failure","title":"Supplier Failure","text":"<pre><code>class SupplierFailure(BaseDisruption):\n    \"\"\"Disruption causing supplier to fail or reduce output.\"\"\"\n\n    def __init__(self, start_time: int, affected_suppliers: list, **kwargs):\n        super().__init__(start_time, **kwargs)\n        self.affected_suppliers = affected_suppliers\n        self.output_reduction = kwargs.get('output_reduction', 1.0)\n\n    def apply(self, context: DisruptionContext):\n        \"\"\"Apply supplier failure disruption.\"\"\"\n\n        for supplier_id in self.affected_suppliers:\n            supplier = context.agents.firms.get(supplier_id)\n\n            if supplier:\n                # Store original production capacity\n                original_capacity = supplier.production_capacity\n                self.original_states[supplier_id] = {\n                    'production_capacity': original_capacity\n                }\n\n                # Reduce production capacity\n                new_capacity = original_capacity * (1 - self.output_reduction)\n                supplier.production_capacity = new_capacity\n\n                self.affected_entities.add(supplier_id)\n\n                # Mark as disrupted for buyer adaptation\n                supplier.disrupted = True\n\n    def remove(self, context: DisruptionContext):\n        \"\"\"Remove supplier failure (recovery).\"\"\"\n\n        for supplier_id in self.affected_entities:\n            supplier = context.agents.firms.get(supplier_id)\n\n            if supplier and supplier_id in self.original_states:\n                # Restore original capacity\n                original = self.original_states[supplier_id]\n                supplier.production_capacity = original['production_capacity']\n                supplier.disrupted = False\n</code></pre>"},{"location":"architecture/disruptions/#trade-restriction","title":"Trade Restriction","text":"<pre><code>class TradeRestriction(BaseDisruption):\n    \"\"\"Disruption affecting international trade flows.\"\"\"\n\n    def __init__(self, start_time: int, affected_countries: list, **kwargs):\n        super().__init__(start_time, **kwargs)\n        self.affected_countries = affected_countries\n        self.import_reduction = kwargs.get('import_reduction', 1.0)\n        self.export_reduction = kwargs.get('export_reduction', 1.0)\n\n    def apply(self, context: DisruptionContext):\n        \"\"\"Apply trade restrictions.\"\"\"\n\n        for country_code in self.affected_countries:\n            country = context.agents.countries.get(country_code)\n\n            if country:\n                # Store original trade capacities\n                self.original_states[country_code] = {\n                    'import_capacity': country.import_capacity,\n                    'export_capacity': country.export_capacity\n                }\n\n                # Apply restrictions\n                country.import_capacity *= (1 - self.import_reduction)\n                country.export_capacity *= (1 - self.export_reduction)\n\n                self.affected_entities.add(country_code)\n</code></pre>"},{"location":"architecture/disruptions/#demand-shock-disruptions","title":"Demand Shock Disruptions","text":"<p>Demand shocks affect household consumption patterns.</p>"},{"location":"architecture/disruptions/#consumption-shock","title":"Consumption Shock","text":"<pre><code>class ConsumptionShock(BaseDisruption):\n    \"\"\"Disruption affecting household consumption demand.\"\"\"\n\n    def __init__(self, start_time: int, demand_changes: dict, **kwargs):\n        super().__init__(start_time, **kwargs)\n        self.demand_changes = demand_changes  # {sector: change_factor}\n\n    def apply(self, context: DisruptionContext):\n        \"\"\"Apply consumption shock to households.\"\"\"\n\n        for household in context.agents.households.values():\n            # Store original consumption targets\n            original_targets = household.consumption_targets.copy()\n            self.original_states[household.pid] = {\n                'consumption_targets': original_targets\n            }\n\n            # Apply demand changes\n            for sector, change_factor in self.demand_changes.items():\n                if sector in household.consumption_targets:\n                    household.consumption_targets[sector] *= change_factor\n\n            self.affected_entities.add(household.pid)\n</code></pre>"},{"location":"architecture/disruptions/#recovery-mechanisms","title":"Recovery Mechanisms","text":""},{"location":"architecture/disruptions/#exponential-recovery","title":"Exponential Recovery","text":"<pre><code>class ExponentialRecovery:\n    \"\"\"Exponential recovery model for disruptions.\"\"\"\n\n    def __init__(self, recovery_rate: float):\n        self.recovery_rate = recovery_rate  # Recovery rate per time step\n\n    def calculate_recovery_factor(self, time_since_disruption: int) -&gt; float:\n        \"\"\"Calculate recovery factor based on time since disruption.\"\"\"\n        return 1 - np.exp(-self.recovery_rate * time_since_disruption)\n\n    def apply_recovery(self, disruption: BaseDisruption, t: int, context: DisruptionContext):\n        \"\"\"Apply gradual recovery to disruption effects.\"\"\"\n\n        if not disruption.is_active(t):\n            return\n\n        time_since_start = t - disruption.start_time\n        recovery_factor = self.calculate_recovery_factor(time_since_start)\n\n        # Apply partial recovery to affected entities\n        for entity_id in disruption.affected_entities:\n            original_state = disruption.original_states.get(entity_id, {})\n\n            # Gradually restore toward original state\n            self._apply_partial_restoration(entity_id, original_state, recovery_factor, context)\n</code></pre>"},{"location":"architecture/disruptions/#priority-based-recovery","title":"Priority-Based Recovery","text":"<pre><code>class PriorityBasedRecovery:\n    \"\"\"Recovery system with priority-based resource allocation.\"\"\"\n\n    def __init__(self, recovery_resources: float):\n        self.recovery_resources = recovery_resources\n        self.recovery_queue = []\n\n    def prioritize_recovery(self, disrupted_entities: list, context: DisruptionContext):\n        \"\"\"Prioritize recovery based on economic importance.\"\"\"\n\n        priority_scores = []\n\n        for entity in disrupted_entities:\n            if hasattr(entity, 'economic_importance'):\n                score = entity.economic_importance\n            elif hasattr(entity, 'centrality_score'):\n                score = entity.centrality_score\n            else:\n                score = 1.0  # Default priority\n\n            priority_scores.append((entity, score))\n\n        # Sort by priority (highest first)\n        priority_scores.sort(key=lambda x: x[1], reverse=True)\n\n        return [entity for entity, score in priority_scores]\n\n    def allocate_recovery_resources(self, t: int, context: DisruptionContext):\n        \"\"\"Allocate recovery resources to highest priority entities.\"\"\"\n\n        remaining_resources = self.recovery_resources\n\n        for entity in self.recovery_queue:\n            if remaining_resources &lt;= 0:\n                break\n\n            recovery_needed = entity.calculate_recovery_requirement()\n            allocated = min(remaining_resources, recovery_needed)\n\n            entity.apply_recovery(allocated)\n            remaining_resources -= allocated\n</code></pre>"},{"location":"architecture/disruptions/#disruption-scenarios","title":"Disruption Scenarios","text":""},{"location":"architecture/disruptions/#monte-carlo-disruptions","title":"Monte Carlo Disruptions","text":"<pre><code>class MonteCarloDisruption:\n    \"\"\"Generate random disruptions for Monte Carlo analysis.\"\"\"\n\n    def __init__(self, probability_distributions: dict):\n        self.distributions = probability_distributions\n\n    def generate_random_disruption(self, t: int, context: DisruptionContext):\n        \"\"\"Generate random disruption based on probability distributions.\"\"\"\n\n        # Determine if disruption occurs\n        if np.random.random() &gt; self.distributions['occurrence_probability']:\n            return None\n\n        # Select disruption type\n        disruption_type = np.random.choice(\n            list(self.distributions['types'].keys()),\n            p=list(self.distributions['types'].values())\n        )\n\n        # Generate disruption parameters\n        if disruption_type == 'transport':\n            return self._generate_random_transport_disruption(t, context)\n        elif disruption_type == 'capital':\n            return self._generate_random_capital_disruption(t, context)\n        # ... other types\n\n    def _generate_random_transport_disruption(self, t: int, context: DisruptionContext):\n        \"\"\"Generate random transport disruption.\"\"\"\n\n        # Random selection of edges to disrupt\n        all_edges = list(context.networks.transport_network.edges())\n        n_affected = np.random.poisson(self.distributions['transport']['mean_edges'])\n        affected_edges = np.random.choice(all_edges, size=min(n_affected, len(all_edges)), replace=False)\n\n        # Random severity\n        severity = np.random.beta(\n            self.distributions['transport']['severity_alpha'],\n            self.distributions['transport']['severity_beta']\n        )\n\n        # Random duration\n        duration = np.random.exponential(self.distributions['transport']['mean_duration'])\n\n        return TransportDisruption(\n            start_time=t,\n            duration=int(duration),\n            affected_edges=affected_edges.tolist(),\n            capacity_reduction=severity\n        )\n</code></pre>"},{"location":"architecture/disruptions/#cascading-disruptions","title":"Cascading Disruptions","text":"<pre><code>class CascadingDisruption:\n    \"\"\"Model cascading effects of disruptions.\"\"\"\n\n    def __init__(self, cascade_threshold: float):\n        self.cascade_threshold = cascade_threshold\n        self.cascaded_disruptions = []\n\n    def check_cascade_conditions(self, primary_disruption: BaseDisruption, t: int, context: DisruptionContext):\n        \"\"\"Check if primary disruption triggers cascading effects.\"\"\"\n\n        affected_agents = self._get_affected_agents(primary_disruption, context)\n\n        for agent in affected_agents:\n            stress_level = self._calculate_stress_level(agent, context)\n\n            if stress_level &gt; self.cascade_threshold:\n                # Generate secondary disruption\n                secondary = self._generate_secondary_disruption(agent, stress_level, t)\n                if secondary:\n                    self.cascaded_disruptions.append(secondary)\n\n    def _calculate_stress_level(self, agent, context: DisruptionContext) -&gt; float:\n        \"\"\"Calculate stress level on agent due to disruption.\"\"\"\n\n        if hasattr(agent, 'calculate_supply_stress'):\n            supply_stress = agent.calculate_supply_stress()\n        else:\n            supply_stress = 0.0\n\n        if hasattr(agent, 'calculate_demand_stress'):\n            demand_stress = agent.calculate_demand_stress()\n        else:\n            demand_stress = 0.0\n\n        return max(supply_stress, demand_stress)\n</code></pre>"},{"location":"architecture/disruptions/#disruption-management","title":"Disruption Management","text":""},{"location":"architecture/disruptions/#disruption-controller","title":"Disruption Controller","text":"<pre><code>class DisruptionController:\n    \"\"\"Manage all disruptions during simulation.\"\"\"\n\n    def __init__(self, disruption_config: list):\n        self.disruptions = []\n        self.active_disruptions = set()\n        self.recovery_system = None\n\n        # Create disruptions from configuration\n        for config in disruption_config:\n            disruption = DisruptionFactory.create_disruption(config, None)\n            self.disruptions.append(disruption)\n\n    def update(self, t: int, context: DisruptionContext):\n        \"\"\"Update disruption states at time t.\"\"\"\n\n        # Check for new disruptions to activate\n        for disruption in self.disruptions:\n            if disruption.start_time == t and disruption not in self.active_disruptions:\n                disruption.apply(context)\n                self.active_disruptions.add(disruption)\n                logger.info(f\"Applied {type(disruption).__name__} at time {t}\")\n\n        # Check for disruptions to deactivate\n        expired_disruptions = []\n        for disruption in self.active_disruptions:\n            if not disruption.is_active(t):\n                disruption.remove(context)\n                expired_disruptions.append(disruption)\n                logger.info(f\"Removed {type(disruption).__name__} at time {t}\")\n\n        for disruption in expired_disruptions:\n            self.active_disruptions.remove(disruption)\n\n        # Apply recovery mechanisms\n        if self.recovery_system:\n            self.recovery_system.update(t, self.active_disruptions, context)\n\n    def get_disruption_summary(self) -&gt; dict:\n        \"\"\"Get summary of all disruptions.\"\"\"\n\n        summary = {\n            'total_disruptions': len(self.disruptions),\n            'active_disruptions': len(self.active_disruptions),\n            'by_type': {},\n            'affected_entities': set()\n        }\n\n        for disruption in self.disruptions:\n            disruption_type = type(disruption).__name__\n            summary['by_type'][disruption_type] = summary['by_type'].get(disruption_type, 0) + 1\n            summary['affected_entities'].update(disruption.affected_entities)\n\n        return summary\n</code></pre>"},{"location":"architecture/disruptions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/disruptions/#efficient-disruption-application","title":"Efficient Disruption Application","text":"<pre><code>class BatchDisruptionProcessor:\n    \"\"\"Process multiple disruptions efficiently.\"\"\"\n\n    def batch_apply_disruptions(self, disruptions: list, context: DisruptionContext):\n        \"\"\"Apply multiple disruptions in batches for efficiency.\"\"\"\n\n        # Group disruptions by type\n        by_type = {}\n        for disruption in disruptions:\n            disruption_type = type(disruption)\n            if disruption_type not in by_type:\n                by_type[disruption_type] = []\n            by_type[disruption_type].append(disruption)\n\n        # Apply each type in batch\n        for disruption_type, type_disruptions in by_type.items():\n            if hasattr(disruption_type, 'batch_apply'):\n                disruption_type.batch_apply(type_disruptions, context)\n            else:\n                # Fall back to individual application\n                for disruption in type_disruptions:\n                    disruption.apply(context)\n</code></pre>"},{"location":"architecture/disruptions/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"architecture/disruptions/#disruption-testing","title":"Disruption Testing","text":"<pre><code>def test_transport_disruption():\n    \"\"\"Test transport disruption application and removal.\"\"\"\n\n    # Set up test context\n    context = create_test_context()\n\n    # Create disruption\n    disruption = TransportDisruption(\n        start_time=10,\n        duration=20,\n        affected_edges=[('node1', 'node2')],\n        capacity_reduction=0.5\n    )\n\n    # Apply disruption\n    original_capacity = context.networks.transport_network['node1']['node2']['capacity']\n    disruption.apply(context)\n\n    # Verify effects\n    disrupted_capacity = context.networks.transport_network['node1']['node2']['capacity']\n    assert disrupted_capacity == original_capacity * 0.5\n\n    # Remove disruption\n    disruption.remove(context)\n\n    # Verify recovery\n    recovered_capacity = context.networks.transport_network['node1']['node2']['capacity']\n    assert recovered_capacity == original_capacity\n</code></pre>"},{"location":"architecture/disruptions/#future-enhancements","title":"Future Enhancements","text":""},{"location":"architecture/disruptions/#planned-disruption-features","title":"Planned Disruption Features","text":"<ol> <li>Machine Learning Disruptions - AI-generated realistic disruption scenarios</li> <li>Climate Change Integration - Weather and climate-related disruptions</li> <li>Cyber Security Disruptions - Information system failures</li> <li>Policy Disruptions - Regulatory and policy changes</li> </ol>"},{"location":"architecture/disruptions/#advanced-recovery-models","title":"Advanced Recovery Models","text":"<ol> <li>Resource-Constrained Recovery - Limited recovery resources</li> <li>Learning-Based Recovery - Improved recovery from experience</li> <li>Cooperative Recovery - Multi-agent recovery coordination</li> <li>Resilience Investment - Proactive resilience building</li> </ol>"},{"location":"architecture/networks/","title":"Network System","text":"<p>DisruptSC models economic and physical relationships through interconnected networks. This section explains the network architecture, types, and how they interact to create realistic supply chain dynamics.</p>"},{"location":"architecture/networks/#network-architecture-overview","title":"Network Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"Network Layer\"\n        SC[Supply Chain Network]\n        TN[Transport Network] \n        MR[MRIO Network]\n    end\n\n    subgraph \"Agent Layer\"\n        F[Firms]\n        H[Households]\n        C[Countries]\n    end\n\n    subgraph \"Spatial Layer\"\n        G[Geographic Data]\n        R[Routes]\n        D[Distances]\n    end\n\n    SC --&gt; F\n    SC --&gt; H\n    SC --&gt; C\n    TN --&gt; R\n    TN --&gt; D\n    MR --&gt; SC\n    G --&gt; TN\n    G --&gt; SC</code></pre> <p>The network system consists of three primary network types that interact to model supply chain dynamics:</p> <ol> <li>Supply Chain Network - Commercial relationships between economic agents</li> <li>Transport Network - Physical infrastructure for moving goods</li> <li>Multi-Regional Input-Output Network - Sectoral economic interdependencies</li> </ol>"},{"location":"architecture/networks/#supply-chain-network","title":"Supply Chain Network","text":"<p>The supply chain network models commercial relationships and flows between economic agents.</p>"},{"location":"architecture/networks/#network-structure","title":"Network Structure","text":"<pre><code>class ScNetwork(nx.DiGraph):\n    \"\"\"Supply chain network extending NetworkX DiGraph.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.flow_data = {}          # Edge flows by time period\n        self.disruption_state = {}   # Current disruption impacts\n\n    def add_commercial_link(self, supplier, buyer, product, weight):\n        \"\"\"Add commercial relationship between agents.\"\"\"\n        self.add_edge(\n            supplier.pid, \n            buyer.pid,\n            product=product,\n            weight=weight,\n            baseline_flow=0\n        )\n</code></pre>"},{"location":"architecture/networks/#node-types","title":"Node Types","text":"Node Type Description Attributes Firm Production companies sector, region, production_capacity Household Final consumers region, population, consumption_budget Country International traders country_code, import_capacity"},{"location":"architecture/networks/#edge-attributes","title":"Edge Attributes","text":"Attribute Type Description <code>product</code> string Product/sector being traded <code>weight</code> float Relationship strength (0-1) <code>baseline_flow</code> float Economic flow value <code>transport_cost</code> float Cost of transport per unit <code>lead_time</code> int Delivery time in time steps <code>reliability</code> float Supplier reliability score"},{"location":"architecture/networks/#network-formation","title":"Network Formation","text":""},{"location":"architecture/networks/#mrio-based-formation","title":"MRIO-Based Formation","text":"<p>For the default MRIO mode, supply chains are generated from input-output coefficients:</p> <pre><code>def create_mrio_supply_chains(self, mrio, agents):\n    \"\"\"Create supply chain links from MRIO coefficients.\"\"\"\n\n    for buyer_sector in mrio.index:\n        for supplier_sector in mrio.columns:\n            coefficient = mrio.loc[buyer_sector, supplier_sector]\n\n            if coefficient &gt; self.io_cutoff:\n                # Find agents in these sectors\n                buyers = self.get_agents_by_sector(buyer_sector)\n                suppliers = self.get_agents_by_sector(supplier_sector)\n\n                # Create links with spatial preferences\n                for buyer in buyers:\n                    selected_suppliers = self.****************************************************************************select_suppliers(\n                        buyer, suppliers, coefficient\n                    )\n\n                    for supplier, weight in selected_suppliers:\n                        self.add_commercial_link(\n                            supplier, buyer, supplier_sector, weight\n                        )\n</code></pre>"},{"location":"architecture/networks/#spatial-supplier-selection","title":"Spatial Supplier Selection","text":"<p>Suppliers are selected based on distance preferences:</p> <pre><code>def select_suppliers(self, buyer, candidates, total_demand):\n    \"\"\"Select suppliers with spatial preference weighting.\"\"\"\n\n    # Calculate distances\n    distances = []\n    for supplier in candidates:\n        dist = buyer.coordinate.distance(supplier.coordinate)\n        distances.append((supplier, dist))\n\n    # Apply spatial preference\n    weights = []\n    for supplier, distance in distances:\n        # Closer suppliers get higher weights\n        spatial_weight = np.exp(-self.distance_decay * distance)\n        capacity_weight = supplier.production_capacity / total_capacity\n        final_weight = spatial_weight * capacity_weight\n        weights.append((supplier, final_weight))\n\n    # Normalize and select top suppliers\n    return self.normalize_and_select(weights, self.max_suppliers)\n</code></pre>"},{"location":"architecture/networks/#network-based-formation","title":"Network-Based Formation","text":"<p>For supplier-buyer network mode, relationships are explicitly defined:</p> <pre><code>def create_network_supply_chains(self, transaction_table):\n    \"\"\"Create supply chains from explicit transaction data.\"\"\"\n\n    for _, row in transaction_table.iterrows():\n        supplier = self.agents[row['supplier_id']]\n        buyer = self.agents[row['buyer_id']]\n        product = row['product_sector']\n        value = row['transaction']\n\n        weight = self.calculate_relationship_weight(value, buyer.total_inputs)\n\n        self.add_commercial_link(supplier, buyer, product, weight)\n</code></pre>"},{"location":"architecture/networks/#network-metrics","title":"Network Metrics","text":"<p>The supply chain network supports various analysis metrics:</p> <pre><code>class NetworkAnalyzer:\n    \"\"\"Analyze supply chain network properties.\"\"\"\n\n    def calculate_centrality(self, network):\n        \"\"\"Calculate various centrality measures.\"\"\"\n        return {\n            'betweenness': nx.betweenness_centrality(network),\n            'degree': dict(network.degree()),\n            'eigenvector': nx.eigenvector_centrality(network),\n            'pagerank': nx.pagerank(network)\n        }\n\n    def find_critical_nodes(self, network, top_n=10):\n        \"\"\"Identify most critical nodes for network connectivity.\"\"\"\n        centrality = nx.betweenness_centrality(network)\n        return sorted(centrality.items(), key=lambda x: x[1], reverse=True)[:top_n]\n\n    def analyze_clustering(self, network):\n        \"\"\"Analyze network clustering and community structure.\"\"\"\n        return {\n            'clustering_coefficient': nx.average_clustering(network),\n            'communities': nx.community.greedy_modularity_communities(network)\n        }\n</code></pre>"},{"location":"architecture/networks/#transport-network","title":"Transport Network","text":"<p>The transport network models physical infrastructure used to move goods between locations.</p>"},{"location":"architecture/networks/#network-structure_1","title":"Network Structure","text":"<pre><code>class TransportNetwork(nx.MultiGraph):\n    \"\"\"Transport network with multiple transport modes.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.modes = ['roads', 'maritime', 'railways', 'airways']\n        self.node_spatial_index = None\n        self.route_cache = {}\n\n    def add_transport_edge(self, from_node, to_node, mode, **attributes):\n        \"\"\"Add transport link between nodes.\"\"\"\n        self.add_edge(\n            from_node,\n            to_node,\n            mode=mode,\n            **attributes\n        )\n</code></pre>"},{"location":"architecture/networks/#transport-modes","title":"Transport Modes","text":""},{"location":"architecture/networks/#road-network","title":"Road Network","text":"<ul> <li>Primary use: Domestic freight and passenger transport</li> <li>Characteristics: Flexible routing, door-to-door delivery</li> <li>Capacity: Vehicle-based, congestion-sensitive</li> </ul> <pre><code>def load_road_network(self, roads_geojson):\n    \"\"\"Load road network from GeoJSON file.\"\"\"\n    roads = gpd.read_file(roads_geojson)\n\n    for _, road in roads.iterrows():\n        from_node, to_node = self.extract_endpoints(road.geometry)\n\n        self.add_edge(\n            from_node, to_node,\n            mode='roads',\n            highway=road.highway,\n            length_km=road.length_km,\n            max_speed=road.get('max_speed', 50),\n            capacity=road.get('capacity', 1000)\n        )\n</code></pre>"},{"location":"architecture/networks/#maritime-network","title":"Maritime Network","text":"<ul> <li>Primary use: International trade, bulk goods</li> <li>Characteristics: High capacity, slow speed, port-to-port</li> <li>Infrastructure: Ports, shipping lanes</li> </ul> <pre><code>def load_maritime_network(self, maritime_geojson):\n    \"\"\"Load maritime routes and port connections.\"\"\"\n    routes = gpd.read_file(maritime_geojson)\n\n    for _, route in routes.iterrows():\n        from_port, to_port = self.extract_ports(route.geometry)\n\n        self.add_edge(\n            from_port, to_port,\n            mode='maritime',\n            route_type=route.route_type,\n            length_km=route.length_km,\n            typical_speed=route.get('speed_kmh', 25),\n            port_from=route.port_from,\n            port_to=route.port_to\n        )\n</code></pre>"},{"location":"architecture/networks/#railway-network","title":"Railway Network","text":"<ul> <li>Primary use: Bulk freight, medium-distance passenger</li> <li>Characteristics: Fixed routes, high capacity, energy efficient</li> <li>Infrastructure: Rail lines, stations, terminals</li> </ul>"},{"location":"architecture/networks/#multimodal-connections","title":"Multimodal Connections","text":"<ul> <li>Purpose: Connect different transport modes</li> <li>Examples: Port-to-road, rail-to-road, airport connections</li> <li>Attributes: Transfer time, handling costs</li> </ul>"},{"location":"architecture/networks/#network-construction","title":"Network Construction","text":""},{"location":"architecture/networks/#spatial-network-creation","title":"Spatial Network Creation","text":"<pre><code>def build_spatial_network(self, geojson_files):\n    \"\"\"Build integrated transport network from spatial data.\"\"\"\n\n    # Load all transport modes\n    for mode, filepath in geojson_files.items():\n        if os.path.exists(filepath):\n            self.load_transport_mode(mode, filepath)\n\n    # Create spatial index for efficient queries\n    self.build_spatial_index()\n\n    # Connect different modes at transfer points\n    self.create_multimodal_connections()\n\n    # Validate network connectivity\n    self.validate_connectivity()\n</code></pre>"},{"location":"architecture/networks/#network-validation","title":"Network Validation","text":"<pre><code>def validate_connectivity(self):\n    \"\"\"Ensure transport network is properly connected.\"\"\"\n\n    # Check each mode separately\n    for mode in self.modes:\n        mode_edges = [(u, v) for u, v, d in self.edges(data=True) if d['mode'] == mode]\n        mode_graph = nx.Graph(mode_edges)\n\n        if not nx.is_connected(mode_graph):\n            components = list(nx.connected_components(mode_graph))\n            logger.warning(f\"{mode} network has {len(components)} disconnected components\")\n\n    # Check overall connectivity\n    if not nx.is_connected(self):\n        logger.error(\"Transport network is not fully connected\")\n        raise NetworkValidationError(\"Disconnected transport network\")\n</code></pre>"},{"location":"architecture/networks/#routing-and-path-finding","title":"Routing and Path Finding","text":""},{"location":"architecture/networks/#shortest-path-calculation","title":"Shortest Path Calculation","text":"<pre><code>class TransportRouter:\n    \"\"\"Handle routing calculations on transport network.\"\"\"\n\n    def __init__(self, transport_network):\n        self.network = transport_network\n        self.route_cache = {}\n\n    def find_shortest_path(self, origin, destination, criteria='time'):\n        \"\"\"Find optimal path between two points.\"\"\"\n\n        # Check cache first\n        cache_key = (origin, destination, criteria)\n        if cache_key in self.route_cache:\n            return self.route_cache[cache_key]\n\n        # Calculate shortest path\n        if criteria == 'time':\n            weight_func = self.calculate_travel_time\n        elif criteria == 'cost':\n            weight_func = self.calculate_transport_cost\n        elif criteria == 'distance':\n            weight_func = lambda u, v, d: d.get('length_km', 0)\n\n        try:\n            path = nx.shortest_path(\n                self.network,\n                origin, destination,\n                weight=weight_func\n            )\n\n            # Cache result\n            self.route_cache[cache_key] = path\n            return path\n\n        except nx.NetworkXNoPath:\n            logger.error(f\"No path found from {origin} to {destination}\")\n            return None\n</code></pre>"},{"location":"architecture/networks/#multi-modal-routing","title":"Multi-Modal Routing","text":"<pre><code>def find_multimodal_route(self, origin, destination, product_type):\n    \"\"\"Find optimal route using multiple transport modes.\"\"\"\n\n    # Consider product characteristics\n    product_constraints = self.get_product_constraints(product_type)\n\n    # Generate candidate routes\n    candidate_routes = []\n\n    # Direct routes (single mode)\n    for mode in self.modes:\n        if self.mode_suitable_for_product(mode, product_type):\n            route = self.find_single_mode_route(origin, destination, mode)\n            if route:\n                candidate_routes.append(route)\n\n    # Multi-modal routes\n    for mode_combination in self.generate_mode_combinations():\n        route = self.find_combined_mode_route(\n            origin, destination, mode_combination\n        )\n        if route:\n            candidate_routes.append(route)\n\n    # Select best route based on cost, time, and reliability\n    return self.select_optimal_route(candidate_routes, product_constraints)\n</code></pre>"},{"location":"architecture/networks/#capacity-and-congestion","title":"Capacity and Congestion","text":""},{"location":"architecture/networks/#edge-capacity-modeling","title":"Edge Capacity Modeling","text":"<pre><code>class CapacityConstrainedNetwork:\n    \"\"\"Transport network with capacity constraints.\"\"\"\n\n    def __init__(self, base_network):\n        self.network = base_network\n        self.current_flows = {}      # Current flow on each edge\n        self.capacities = {}         # Maximum capacity of each edge\n        self.congestion_factors = {} # Congestion impact on speed/cost\n\n    def update_flows(self, new_flows):\n        \"\"\"Update current flows and recalculate congestion.\"\"\"\n        self.current_flows = new_flows\n\n        for edge, flow in new_flows.items():\n            capacity = self.capacities.get(edge, float('inf'))\n            utilization = flow / capacity if capacity &gt; 0 else 0\n\n            # Update congestion factor\n            self.congestion_factors[edge] = self.calculate_congestion(utilization)\n\n    def calculate_congestion(self, utilization):\n        \"\"\"Calculate congestion impact based on utilization.\"\"\"\n        if utilization &lt;= 0.8:\n            return 1.0  # No congestion\n        elif utilization &lt;= 1.0:\n            return 1.0 + 2.0 * (utilization - 0.8)  # Linear increase\n        else:\n            return 1.4 + 5.0 * (utilization - 1.0)  # Severe congestion\n</code></pre>"},{"location":"architecture/networks/#multi-regional-input-output-network","title":"Multi-Regional Input-Output Network","text":"<p>The MRIO network represents sectoral interdependencies and trade flows.</p>"},{"location":"architecture/networks/#mrio-structure","title":"MRIO Structure","text":"<pre><code>class Mrio(pd.DataFrame):\n    \"\"\"Extended DataFrame for multi-regional input-output data.\"\"\"\n\n    def __init__(self, data, **kwargs):\n        super().__init__(data, **kwargs)\n        self._validate_structure()\n\n    def _validate_structure(self):\n        \"\"\"Validate MRIO table structure.\"\"\"\n        # Check square matrix\n        if self.shape[0] != self.shape[1]:\n            raise ValueError(\"MRIO must be square matrix\")\n\n        # Check non-negative values\n        if (self &lt; 0).any().any():\n            raise ValueError(\"MRIO cannot contain negative values\")\n\n    @property\n    def sectors(self):\n        \"\"\"Get list of production sectors.\"\"\"\n        return [col for col in self.columns if not col.startswith(('HH_', 'Export_'))]\n\n    @property\n    def final_demand(self):\n        \"\"\"Get final demand columns.\"\"\"\n        return [col for col in self.columns if col.startswith('HH_')]\n\n    @property\n    def exports(self):\n        \"\"\"Get export columns.\"\"\"\n        return [col for col in self.columns if col.startswith('Export_')]\n</code></pre>"},{"location":"architecture/networks/#technical-coefficients","title":"Technical Coefficients","text":"<pre><code>def calculate_technical_coefficients(self):\n    \"\"\"Calculate input-output technical coefficients.\"\"\"\n\n    # Get intermediate flows (sectors only)\n    intermediate = self[self.sectors].loc[self.sectors]\n\n    # Calculate total inputs for each sector\n    total_inputs = intermediate.sum(axis=0)\n\n    # Calculate coefficients (inputs per unit of output)\n    coefficients = intermediate.div(total_inputs, axis=1)\n    coefficients = coefficients.fillna(0)\n\n    return coefficients\n\ndef calculate_leontief_inverse(self):\n    \"\"\"Calculate Leontief inverse matrix.\"\"\"\n    A = self.calculate_technical_coefficients()\n    I = np.eye(len(A))\n\n    try:\n        L = np.linalg.inv(I - A.values)\n        return pd.DataFrame(L, index=A.index, columns=A.columns)\n    except np.linalg.LinAlgError:\n        raise ValueError(\"Leontief inverse calculation failed - check MRIO structure\")\n</code></pre>"},{"location":"architecture/networks/#economic-flow-modeling","title":"Economic Flow Modeling","text":"<pre><code>class EconomicFlowModel:\n    \"\"\"Model economic flows based on MRIO structure.\"\"\"\n\n    def __init__(self, mrio, agents):\n        self.mrio = mrio\n        self.agents = agents\n        self.flow_matrix = None\n\n    def calculate_equilibrium_flows(self):\n        \"\"\"Calculate equilibrium economic flows.\"\"\"\n\n        # Get production capacities\n        production = self.get_agent_production()\n\n        # Get final demand\n        final_demand = self.get_agent_demand()\n\n        # Solve for equilibrium flows\n        A = self.mrio.calculate_technical_coefficients()\n        L = self.mrio.calculate_leontief_inverse()\n\n        # Total output = Leontief inverse * final demand\n        total_output = L @ final_demand\n\n        # Intermediate flows = coefficients * total output\n        self.flow_matrix = A.values * total_output.values\n\n        return self.flow_matrix\n</code></pre>"},{"location":"architecture/networks/#network-integration","title":"Network Integration","text":""},{"location":"architecture/networks/#agent-network-mapping","title":"Agent-Network Mapping","text":"<pre><code>class NetworkIntegrator:\n    \"\"\"Integrate agents with network systems.\"\"\"\n\n    def __init__(self, agents, sc_network, transport_network):\n        self.agents = agents\n        self.sc_network = sc_network\n        self.transport_network = transport_network\n\n    def map_agents_to_transport(self):\n        \"\"\"Map agents to nearest transport network nodes.\"\"\"\n\n        for agent in self.agents.values():\n            # Find nearest transport node\n            nearest_node = self.find_nearest_transport_node(agent.coordinate)\n\n            # Store mapping\n            agent.transport_node = nearest_node\n\n            # Add connection if distance is significant\n            distance = agent.coordinate.distance(nearest_node.coordinate)\n            if distance &gt; self.connection_threshold:\n                self.add_last_mile_connection(agent, nearest_node, distance)\n\n    def synchronize_networks(self):\n        \"\"\"Ensure consistency between different network layers.\"\"\"\n\n        # Check that all supply chain links have transport paths\n        for supplier, buyer in self.sc_network.edges():\n            supplier_node = self.agents[supplier].transport_node\n            buyer_node = self.agents[buyer].transport_node\n\n            if not self.transport_network.has_path(supplier_node, buyer_node):\n                logger.warning(f\"No transport path from {supplier} to {buyer}\")\n</code></pre>"},{"location":"architecture/networks/#flow-allocation","title":"Flow Allocation","text":"<pre><code>class FlowAllocator:\n    \"\"\"Allocate economic flows to transport network.\"\"\"\n\n    def allocate_flows_to_routes(self, economic_flows, routes):\n        \"\"\"Map economic flows to physical transport routes.\"\"\"\n\n        transport_flows = {}\n\n        for (supplier, buyer), economic_flow in economic_flows.items():\n            # Get route between agents\n            route = routes.get((supplier, buyer))\n\n            if route:\n                # Convert economic flow to physical volume\n                product_type = self.sc_network[supplier][buyer]['product']\n                usd_per_ton = self.get_product_density(product_type)\n\n                if usd_per_ton &gt; 0:\n                    volume = economic_flow / usd_per_ton\n\n                    # Allocate volume to route edges\n                    for i in range(len(route) - 1):\n                        edge = (route[i], route[i+1])\n                        transport_flows[edge] = transport_flows.get(edge, 0) + volume\n\n        return transport_flows\n</code></pre>"},{"location":"architecture/networks/#network-disruptions","title":"Network Disruptions","text":""},{"location":"architecture/networks/#disruption-modeling","title":"Disruption Modeling","text":"<pre><code>class NetworkDisruption:\n    \"\"\"Model network disruptions and their impacts.\"\"\"\n\n    def apply_transport_disruption(self, affected_edges, severity):\n        \"\"\"Apply disruption to transport network edges.\"\"\"\n\n        for edge in affected_edges:\n            if self.transport_network.has_edge(*edge):\n                # Reduce capacity\n                original_capacity = self.transport_network[edge[0]][edge[1]]['capacity']\n                new_capacity = original_capacity * (1 - severity)\n                self.transport_network[edge[0]][edge[1]]['capacity'] = new_capacity\n\n                # Increase travel time\n                original_time = self.transport_network[edge[0]][edge[1]]['travel_time']\n                congestion_factor = 1.0 / (1 - severity + 0.1)\n                new_time = original_time * congestion_factor\n                self.transport_network[edge[0]][edge[1]]['travel_time'] = new_time\n\n    def apply_supply_chain_disruption(self, affected_firms):\n        \"\"\"Apply disruption to supply chain network.\"\"\"\n\n        for firm_id in affected_firms:\n            # Remove or reduce outgoing links\n            outgoing_edges = list(self.sc_network.out_edges(firm_id))\n            for edge in outgoing_edges:\n                # Reduce relationship weight\n                current_weight = self.sc_network[edge[0]][edge[1]]['weight']\n                self.sc_network[edge[0]][edge[1]]['weight'] = current_weight * 0.1\n</code></pre>"},{"location":"architecture/networks/#network-recovery","title":"Network Recovery","text":"<pre><code>class NetworkRecovery:\n    \"\"\"Model network recovery after disruptions.\"\"\"\n\n    def update_recovery(self, t, recovery_rates):\n        \"\"\"Update network recovery state.\"\"\"\n\n        for edge, rate in recovery_rates.items():\n            current_state = self.disruption_state.get(edge, 1.0)\n\n            # Exponential recovery\n            new_state = min(1.0, current_state + rate * (1 - current_state))\n            self.disruption_state[edge] = new_state\n\n            # Update network attributes\n            self.apply_recovery_state(edge, new_state)\n</code></pre>"},{"location":"architecture/networks/#performance-optimization","title":"Performance Optimization","text":""},{"location":"architecture/networks/#network-caching","title":"Network Caching","text":"<pre><code>class NetworkCache:\n    \"\"\"Cache expensive network calculations.\"\"\"\n\n    def __init__(self, max_size=10000):\n        self.route_cache = {}\n        self.distance_cache = {}\n        self.max_size = max_size\n\n    def get_cached_route(self, origin, destination):\n        \"\"\"Get cached route if available.\"\"\"\n        key = (origin, destination)\n        return self.route_cache.get(key)\n\n    def cache_route(self, origin, destination, route):\n        \"\"\"Cache route calculation.\"\"\"\n        if len(self.route_cache) &gt;= self.max_size:\n            self.clear_oldest_entries()\n\n        key = (origin, destination)\n        self.route_cache[key] = route\n</code></pre>"},{"location":"architecture/networks/#parallel-processing","title":"Parallel Processing","text":"<pre><code>class ParallelNetworkProcessor:\n    \"\"\"Process network operations in parallel.\"\"\"\n\n    def calculate_routes_parallel(self, origin_destination_pairs):\n        \"\"\"Calculate multiple routes in parallel.\"\"\"\n\n        with ProcessPoolExecutor(max_workers=self.max_workers) as executor:\n            futures = {\n                executor.submit(self.calculate_single_route, od): od\n                for od in origin_destination_pairs\n            }\n\n            routes = {}\n            for future in as_completed(futures):\n                od_pair = futures[future]\n                try:\n                    route = future.result()\n                    routes[od_pair] = route\n                except Exception as e:\n                    logger.error(f\"Route calculation failed for {od_pair}: {e}\")\n\n            return routes\n</code></pre>"},{"location":"architecture/networks/#network-analysis-and-visualization","title":"Network Analysis and Visualization","text":""},{"location":"architecture/networks/#network-metrics_1","title":"Network Metrics","text":"<pre><code>def analyze_network_topology(network):\n    \"\"\"Comprehensive network topology analysis.\"\"\"\n\n    metrics = {\n        'nodes': network.number_of_nodes(),\n        'edges': network.number_of_edges(),\n        'density': nx.density(network),\n        'average_clustering': nx.average_clustering(network),\n        'diameter': nx.diameter(network) if nx.is_connected(network) else None,\n        'average_path_length': nx.average_shortest_path_length(network) if nx.is_connected(network) else None\n    }\n\n    # Centrality measures\n    metrics['betweenness_centrality'] = nx.betweenness_centrality(network)\n    metrics['degree_centrality'] = nx.degree_centrality(network)\n\n    return metrics\n</code></pre>"},{"location":"architecture/networks/#visualization","title":"Visualization","text":"<pre><code>def visualize_network(network, output_path, layout='spring'):\n    \"\"\"Create network visualization.\"\"\"\n\n    plt.figure(figsize=(12, 8))\n\n    if layout == 'spring':\n        pos = nx.spring_layout(network)\n    elif layout == 'geographic':\n        pos = {node: (data['longitude'], data['latitude']) \n               for node, data in network.nodes(data=True)}\n\n    # Draw network\n    nx.draw(network, pos, \n            node_size=50, \n            edge_color='gray', \n            node_color='red',\n            alpha=0.7)\n\n    plt.title(\"Network Structure\")\n    plt.savefig(output_path, dpi=300, bbox_inches='tight')\n    plt.close()\n</code></pre>"},{"location":"architecture/networks/#future-enhancements","title":"Future Enhancements","text":""},{"location":"architecture/networks/#planned-network-features","title":"Planned Network Features","text":"<ol> <li>Dynamic Networks - Time-varying network structure</li> <li>Stochastic Networks - Probabilistic edge weights and capacities</li> <li>Multi-Layer Networks - Explicit modeling of network interdependencies</li> <li>Real-Time Optimization - Dynamic routing based on current conditions</li> </ol>"},{"location":"architecture/networks/#advanced-network-models","title":"Advanced Network Models","text":"<ol> <li>Network Resilience - Formal resilience metrics and optimization</li> <li>Adaptive Networks - Self-organizing network structures</li> <li>Information Networks - Explicit modeling of information flows</li> <li>Social Networks - Agent-to-agent communication and influence</li> </ol>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>DisruptSC is a spatial agent-based model designed to simulate supply chain disruptions and their economic impacts. This section explains the model's architecture, core components, and design patterns.</p>"},{"location":"architecture/overview/#model-philosophy","title":"Model Philosophy","text":"<p>DisruptSC follows these core principles:</p> <ul> <li>Agent-based modeling - Economic actors (firms, households, countries) are modeled as autonomous agents</li> <li>Spatial representation - All agents and infrastructure are geo-located for realistic modeling</li> <li>Network-based interactions - Supply chains and transport are modeled as interconnected networks  </li> <li>Data-driven parameterization - Model uses real economic and geographic data</li> <li>Modular design - Components can be extended or replaced independently</li> </ul>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    A[Input Data] --&gt; B[Model Builder]\n    B --&gt; C[Agent System]\n    B --&gt; D[Network System] \n    B --&gt; E[Transport System]\n\n    C --&gt; F[Simulation Engine]\n    D --&gt; F\n    E --&gt; F\n\n    F --&gt; G[Disruption System]\n    G --&gt; F\n\n    F --&gt; H[Output System]\n    H --&gt; I[Analysis Results]\n\n    subgraph \"Core Systems\"\n        C\n        D\n        E\n        F\n        G\n    end</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#1-data-layer","title":"1. Data Layer","text":"<p>Purpose: Manage input data and provide consistent access</p> <p>Key Classes: - <code>Mrio</code> - Multi-regional input-output tables (extends pandas DataFrame) - <code>Parameters</code> - Configuration management - <code>Paths</code> - Data path resolution</p> <p>Data Types: - Economic data (MRIO, sector tables, firm data) - Transport networks (roads, maritime, railways) - Spatial data (agent locations, administrative boundaries)</p>"},{"location":"architecture/overview/#2-agent-system","title":"2. Agent System","text":"<p>Purpose: Represent economic actors and their behaviors</p> <p>Agent Types:</p> <pre><code>classDiagram\n    class BaseAgent {\n        +pid: str\n        +region: str\n        +coordinate: Point\n        +update()\n        +reset()\n    }\n\n    class Firm {\n        +sector: str\n        +production_target: float\n        +inventory: dict\n        +produce()\n        +purchase()\n        +sell()\n    }\n\n    class Household {\n        +population: int\n        +consumption_budget: float\n        +consume()\n    }\n\n    class Country {\n        +trade_flows: dict\n        +export()\n        +import()\n    }\n\n    BaseAgent &lt;|-- Firm\n    BaseAgent &lt;|-- Household  \n    BaseAgent &lt;|-- Country</code></pre> <p>Key Features: - Autonomous behavior - Each agent makes independent decisions - Spatial awareness - Agents know their location and can interact spatially - Memory - Agents maintain state across time steps - Adaptability - Agents can adjust behavior based on conditions</p>"},{"location":"architecture/overview/#3-network-system","title":"3. Network System","text":"<p>Purpose: Model relationships and flows between agents</p> <p>Network Types:</p>"},{"location":"architecture/overview/#supply-chain-network-scnetwork","title":"Supply Chain Network (<code>ScNetwork</code>)","text":"<ul> <li>Extends NetworkX DiGraph</li> <li>Nodes: Economic agents (firms, households, countries)</li> <li>Edges: Commercial relationships with flow volumes</li> <li>Weights: Relationship strength, geographic distance</li> </ul>"},{"location":"architecture/overview/#transport-network-transportnetwork","title":"Transport Network (<code>TransportNetwork</code>)","text":"<ul> <li>Spatial graph of infrastructure</li> <li>Nodes: Geographic locations, ports, border crossings</li> <li>Edges: Roads, maritime routes, railways</li> <li>Attributes: Capacity, speed, costs</li> </ul>"},{"location":"architecture/overview/#multi-regional-input-output-network","title":"Multi-Regional Input-Output Network","text":"<ul> <li>Economic interdependencies between sectors</li> <li>Technical coefficients define input requirements</li> <li>Final demand drives the system</li> </ul>"},{"location":"architecture/overview/#4-simulation-engine","title":"4. Simulation Engine","text":"<p>Purpose: Orchestrate model execution and time progression</p> <p>Execution Flow:</p> <pre><code>sequenceDiagram\n    participant SE as Simulation Engine\n    participant A as Agents\n    participant N as Networks\n    participant T as Transport\n    participant D as Disruptions\n\n    SE-&gt;&gt;A: Initialize state\n    loop Time Steps\n        SE-&gt;&gt;D: Check for new events\n        D-&gt;&gt;N: Apply disruptions\n        SE-&gt;&gt;A: Update production targets\n        SE-&gt;&gt;A: Execute purchases\n        SE-&gt;&gt;T: Route shipments\n        SE-&gt;&gt;A: Deliver goods\n        SE-&gt;&gt;A: Update inventories\n        SE-&gt;&gt;SE: Collect outputs\n    end</code></pre> <p>Key Features: - Discrete time steps - Day/week/month resolution - Event-driven - Disruptions trigger at specified times - State management - Consistent agent and network state - Data collection - Comprehensive output tracking</p>"},{"location":"architecture/overview/#5-disruption-system","title":"5. Disruption System","text":"<p>Purpose: Model various types of supply chain disruptions</p> <p>Architecture:</p> <pre><code>classDiagram\n    class DisruptionFactory {\n        +registered_types: dict\n        +create_disruption(config)\n        +register_type(name, creator)\n    }\n\n    class BaseDisruption {\n        +start_time: int\n        +duration: int\n        +apply(context)\n        +remove(context)\n    }\n\n    class TransportDisruption {\n        +affected_edges: list\n        +capacity_reduction: float\n        +apply(context)\n    }\n\n    class CapitalDestruction {\n        +affected_firms: dict\n        +damage_amounts: dict\n        +apply(context)\n    }\n\n    DisruptionFactory --&gt; BaseDisruption\n    BaseDisruption &lt;|-- TransportDisruption\n    BaseDisruption &lt;|-- CapitalDestruction</code></pre> <p>Disruption Types: - Transport disruptions - Road/port closures, capacity reductions - Capital destruction - Damage to production facilities - Supply disruptions - Supplier failures, trade restrictions - Demand shocks - Changes in consumer demand</p>"},{"location":"architecture/overview/#data-flow-architecture","title":"Data Flow Architecture","text":""},{"location":"architecture/overview/#input-processing","title":"Input Processing","text":"<pre><code>graph LR\n    A[Raw Data Files] --&gt; B[Data Validators]\n    B --&gt; C[Data Loaders]\n    C --&gt; D[Model Objects]\n\n    A1[MRIO CSV] --&gt; B\n    A2[Transport GeoJSON] --&gt; B\n    A3[Spatial Points] --&gt; B\n    A4[Parameters YAML] --&gt; B\n\n    D --&gt; E[Model Builder]\n    E --&gt; F[Initialized Model]</code></pre>"},{"location":"architecture/overview/#simulation-data-flow","title":"Simulation Data Flow","text":"<pre><code>graph TB\n    A[Agent State] --&gt; B[Decision Making]\n    B --&gt; C[Action Execution]\n    C --&gt; D[Network Updates]\n    D --&gt; E[Transport Routing]\n    E --&gt; F[Flow Allocation]\n    F --&gt; G[State Updates]\n    G --&gt; A\n\n    H[Disruption Events] --&gt; D\n    I[Data Collectors] --&gt; G\n    I --&gt; J[Output Files]</code></pre>"},{"location":"architecture/overview/#component-interactions","title":"Component Interactions","text":""},{"location":"architecture/overview/#model-initialization","title":"Model Initialization","text":"<ol> <li>Data Loading: Read and validate all input files</li> <li>Network Construction: Build transport and supply chain networks</li> <li>Agent Creation: Generate agents based on economic and spatial data</li> <li>Routing Calculation: Pre-compute optimal transport routes</li> <li>Equilibrium: Establish baseline economic equilibrium</li> </ol>"},{"location":"architecture/overview/#runtime-interactions","title":"Runtime Interactions","text":"<ol> <li>Event Processing: Check for disruption events</li> <li>Production Planning: Firms set production targets</li> <li>Purchasing: Agents place orders with suppliers</li> <li>Transport Planning: Route shipments through network</li> <li>Delivery: Execute transport and update inventories</li> <li>Market Clearing: Balance supply and demand</li> </ol>"},{"location":"architecture/overview/#design-patterns","title":"Design Patterns","text":""},{"location":"architecture/overview/#factory-pattern","title":"Factory Pattern","text":"<p>Used for creating disruptions dynamically based on configuration:</p> <pre><code>class DisruptionFactory:\n    _creators = {}\n\n    @classmethod\n    def register(cls, disruption_type, creator_func):\n        cls._creators[disruption_type] = creator_func\n\n    @classmethod\n    def create(cls, config):\n        disruption_type = config['type']\n        creator = cls._creators[disruption_type]\n        return creator(config)\n</code></pre>"},{"location":"architecture/overview/#builder-pattern","title":"Builder Pattern","text":"<p>Model construction is complex and uses builders:</p> <pre><code>class ModelBuilder:\n    def __init__(self, parameters):\n        self.parameters = parameters\n\n    def build_transport_network(self):\n        # Complex network construction\n        pass\n\n    def build_agents(self):\n        # Agent creation from data\n        pass\n\n    def build_supply_chains(self):\n        # Network relationship creation\n        pass\n</code></pre>"},{"location":"architecture/overview/#observer-pattern","title":"Observer Pattern","text":"<p>Data collection observes simulation state:</p> <pre><code>class DataCollector:\n    def __init__(self):\n        self.observers = []\n\n    def notify(self, event_type, data):\n        for observer in self.observers:\n            observer.update(event_type, data)\n</code></pre>"},{"location":"architecture/overview/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/overview/#computational-complexity","title":"Computational Complexity","text":"Component Complexity Bottlenecks Agent Updates O(n) Large agent populations Network Routing O(n log n) Complex transport networks Flow Allocation O(n\u00b2) Dense supply chain networks Spatial Queries O(log n) Geographic lookups"},{"location":"architecture/overview/#memory-management","title":"Memory Management","text":"<ul> <li>Caching: Expensive computations (routing, distances) are cached</li> <li>Lazy Loading: Data loaded only when needed</li> <li>State Management: Minimal agent state to reduce memory</li> <li>Batch Processing: Large operations processed in batches</li> </ul>"},{"location":"architecture/overview/#scalability-strategies","title":"Scalability Strategies","text":"<ol> <li>Hierarchical Networks: Reduce network complexity through aggregation</li> <li>Spatial Indexing: Efficient geographic queries</li> <li>Parallel Processing: Multi-threaded routing and agent updates</li> <li>Incremental Updates: Only update changed components</li> </ol>"},{"location":"architecture/overview/#extension-points","title":"Extension Points","text":""},{"location":"architecture/overview/#adding-new-agent-types","title":"Adding New Agent Types","text":"<pre><code>class NewAgentType(BaseAgent):\n    def __init__(self, pid, **kwargs):\n        super().__init__(pid, **kwargs)\n        # Custom initialization\n\n    def update(self, t, **kwargs):\n        # Custom behavior\n        super().update(t, **kwargs)\n</code></pre>"},{"location":"architecture/overview/#custom-disruption-types","title":"Custom Disruption Types","text":"<pre><code>def create_custom_disruption(config, context):\n    return CustomDisruption(\n        start_time=config['start_time'],\n        custom_param=config['custom_param']\n    )\n\nDisruptionFactory.register('custom_type', create_custom_disruption)\n</code></pre>"},{"location":"architecture/overview/#new-transport-modes","title":"New Transport Modes","text":"<pre><code>class CustomTransportMode:\n    def calculate_cost(self, distance, volume):\n        # Custom cost calculation\n        pass\n\n    def calculate_time(self, distance, conditions):\n        # Custom time calculation  \n        pass\n</code></pre>"},{"location":"architecture/overview/#validation-and-testing","title":"Validation and Testing","text":""},{"location":"architecture/overview/#input-validation","title":"Input Validation","text":"<ul> <li>Schema validation - Check file formats and structures</li> <li>Data consistency - Verify cross-file relationships</li> <li>Range validation - Ensure realistic parameter values</li> <li>Network validation - Check connectivity and topology</li> </ul>"},{"location":"architecture/overview/#model-validation","title":"Model Validation","text":"<ul> <li>Mass balance - Economic flows balance at each node</li> <li>Spatial consistency - Geographic relationships are realistic</li> <li>Temporal consistency - State transitions are valid</li> <li>Behavioral validation - Agent actions are reasonable</li> </ul>"},{"location":"architecture/overview/#performance-testing","title":"Performance Testing","text":"<ul> <li>Scalability tests - Performance with increasing model size</li> <li>Memory profiling - Track memory usage patterns</li> <li>Benchmarking - Compare performance across versions</li> </ul>"},{"location":"architecture/overview/#future-architecture-considerations","title":"Future Architecture Considerations","text":""},{"location":"architecture/overview/#planned-enhancements","title":"Planned Enhancements","text":"<ol> <li>Microservices Architecture - Decompose into independent services</li> <li>Stream Processing - Real-time disruption handling</li> <li>Cloud Deployment - Distributed computing capabilities</li> <li>API Layer - REST/GraphQL interfaces for external integration</li> </ol>"},{"location":"architecture/overview/#emerging-technologies","title":"Emerging Technologies","text":"<ol> <li>Machine Learning Integration - Predictive agent behaviors</li> <li>Graph Databases - More efficient network storage</li> <li>Distributed Computing - Spark/Dask integration</li> <li>Containerization - Docker-based deployment</li> </ol>"},{"location":"architecture/simulation/","title":"Simulation Engine","text":"<p>The simulation engine orchestrates the execution of DisruptSC models, managing time progression, agent interactions, and data collection. This document explains the simulation architecture, execution flow, and key components.</p>"},{"location":"architecture/simulation/#simulation-architecture","title":"Simulation Architecture","text":""},{"location":"architecture/simulation/#core-components","title":"Core Components","text":"<pre><code>graph TB\n    subgraph \"Simulation Engine\"\n        SE[Simulation Controller]\n        TM[Time Manager]\n        EM[Event Manager]\n        DM[Data Manager]\n    end\n\n    subgraph \"Model Components\"\n        A[Agents]\n        N[Networks]\n        D[Disruptions]\n        E[Environment]\n    end\n\n    subgraph \"External Systems\"\n        I[Input Data]\n        O[Output Data]\n        L[Logging]\n    end\n\n    SE --&gt; TM\n    SE --&gt; EM\n    SE --&gt; DM\n\n    TM --&gt; A\n    TM --&gt; N\n    EM --&gt; D\n    DM --&gt; O\n\n    I --&gt; SE\n    SE --&gt; L</code></pre>"},{"location":"architecture/simulation/#simulation-controller","title":"Simulation Controller","text":"<p>The main simulation controller manages the overall execution:</p> <pre><code>class Simulation:\n    \"\"\"Main simulation controller for DisruptSC.\"\"\"\n\n    def __init__(self, model, parameters):\n        self.model = model\n        self.parameters = parameters\n        self.current_time = 0\n        self.max_time = parameters.t_final\n\n        # Core managers\n        self.time_manager = TimeManager(parameters.time_resolution)\n        self.event_manager = EventManager()\n        self.data_manager = DataManager(parameters.output_config)\n        self.disruption_controller = DisruptionController(parameters.events)\n\n        # State tracking\n        self.simulation_state = SimulationState()\n        self.convergence_checker = ConvergenceChecker()\n        self.performance_monitor = PerformanceMonitor()\n\n    def run(self):\n        \"\"\"Execute the complete simulation.\"\"\"\n\n        logger.info(\"Starting simulation\")\n        self.performance_monitor.start()\n\n        try:\n            # Initialize simulation\n            self.initialize()\n\n            # Main simulation loop\n            while self.should_continue():\n                self.execute_time_step()\n                self.current_time += 1\n\n            # Finalize simulation\n            self.finalize()\n\n        except Exception as e:\n            logger.error(f\"Simulation failed: {e}\")\n            raise\n        finally:\n            self.performance_monitor.stop()\n            logger.info(f\"Simulation completed in {self.performance_monitor.elapsed_time:.2f} seconds\")\n\n    def should_continue(self) -&gt; bool:\n        \"\"\"Check if simulation should continue.\"\"\"\n\n        # Time limit check\n        if self.current_time &gt;= self.max_time:\n            return False\n\n        # Convergence check (for equilibrium simulations)\n        if self.parameters.epsilon_stop_condition:\n            if self.convergence_checker.has_converged(self.simulation_state):\n                logger.info(f\"Simulation converged at time {self.current_time}\")\n                return False\n\n        # Early termination conditions\n        if self.simulation_state.should_terminate():\n            logger.info(f\"Early termination at time {self.current_time}\")\n            return False\n\n        return True\n</code></pre>"},{"location":"architecture/simulation/#time-management","title":"Time Management","text":""},{"location":"architecture/simulation/#time-resolution","title":"Time Resolution","text":"<p>DisruptSC supports multiple time resolutions:</p> <pre><code>class TimeManager:\n    \"\"\"Manage simulation time and temporal operations.\"\"\"\n\n    def __init__(self, time_resolution: str):\n        self.resolution = time_resolution\n        self.resolution_mapping = {\n            'day': 1,\n            'week': 7,\n            'month': 30,\n            'quarter': 90,\n            'year': 365\n        }\n\n        if time_resolution not in self.resolution_mapping:\n            raise ValueError(f\"Invalid time resolution: {time_resolution}\")\n\n        self.days_per_step = self.resolution_mapping[time_resolution]\n\n    def convert_to_simulation_time(self, real_time_days: float) -&gt; int:\n        \"\"\"Convert real time (days) to simulation time steps.\"\"\"\n        return int(real_time_days / self.days_per_step)\n\n    def convert_to_real_time(self, simulation_steps: int) -&gt; float:\n        \"\"\"Convert simulation time steps to real time (days).\"\"\"\n        return simulation_steps * self.days_per_step\n\n    def get_temporal_weights(self, t: int) -&gt; dict:\n        \"\"\"Get temporal weights for seasonal/cyclical effects.\"\"\"\n\n        # Convert to day of year\n        day_of_year = (t * self.days_per_step) % 365\n\n        # Seasonal weights (example: agriculture seasonality)\n        seasonal_weight = 1.0 + 0.3 * np.sin(2 * np.pi * day_of_year / 365)\n\n        return {\n            'seasonal': seasonal_weight,\n            'trend': 1.0,  # Long-term trend factor\n            'cyclical': 1.0  # Business cycle factor\n        }\n</code></pre>"},{"location":"architecture/simulation/#temporal-scheduling","title":"Temporal Scheduling","text":"<pre><code>class EventScheduler:\n    \"\"\"Schedule and manage time-based events.\"\"\"\n\n    def __init__(self):\n        self.scheduled_events = {}  # {time: [events]}\n        self.recurring_events = []\n\n    def schedule_event(self, time: int, event: callable, **kwargs):\n        \"\"\"Schedule event at specific time.\"\"\"\n        if time not in self.scheduled_events:\n            self.scheduled_events[time] = []\n\n        self.scheduled_events[time].append({\n            'function': event,\n            'kwargs': kwargs\n        })\n\n    def schedule_recurring(self, start_time: int, interval: int, event: callable, **kwargs):\n        \"\"\"Schedule recurring event.\"\"\"\n        self.recurring_events.append({\n            'start_time': start_time,\n            'interval': interval,\n            'function': event,\n            'kwargs': kwargs,\n            'last_execution': start_time - interval\n        })\n\n    def execute_scheduled_events(self, t: int):\n        \"\"\"Execute all events scheduled for time t.\"\"\"\n\n        # Execute one-time events\n        if t in self.scheduled_events:\n            for event in self.scheduled_events[t]:\n                try:\n                    event['function'](**event['kwargs'])\n                except Exception as e:\n                    logger.error(f\"Event execution failed at time {t}: {e}\")\n\n            del self.scheduled_events[t]\n\n        # Execute recurring events\n        for event in self.recurring_events:\n            if (t &gt;= event['start_time'] and \n                (t - event['last_execution']) &gt;= event['interval']):\n\n                try:\n                    event['function'](**event['kwargs'])\n                    event['last_execution'] = t\n                except Exception as e:\n                    logger.error(f\"Recurring event execution failed at time {t}: {e}\")\n</code></pre>"},{"location":"architecture/simulation/#execution-flow","title":"Execution Flow","text":""},{"location":"architecture/simulation/#time-step-execution","title":"Time Step Execution","text":"<pre><code>def execute_time_step(self):\n    \"\"\"Execute single simulation time step.\"\"\"\n\n    t = self.current_time\n    logger.debug(f\"Executing time step {t}\")\n\n    # 1. Update temporal environment\n    self.update_environment(t)\n\n    # 2. Process scheduled events\n    self.event_manager.execute_scheduled_events(t)\n\n    # 3. Update disruptions\n    self.disruption_controller.update(t, self.get_disruption_context())\n\n    # 4. Agent decision making\n    self.execute_agent_decisions(t)\n\n    # 5. Execute agent actions\n    self.execute_agent_actions(t)\n\n    # 6. Update networks and flows\n    self.update_networks(t)\n\n    # 7. Market clearing and equilibration\n    self.clear_markets(t)\n\n    # 8. Data collection\n    self.data_manager.collect_data(t, self.simulation_state)\n\n    # 9. Update simulation state\n    self.simulation_state.update(t, self.model)\n</code></pre>"},{"location":"architecture/simulation/#agent-decision-sequence","title":"Agent Decision Sequence","text":"<pre><code>sequenceDiagram\n    participant SE as Simulation Engine\n    participant F as Firms\n    participant H as Households\n    participant C as Countries\n    participant M as Markets\n\n    SE-&gt;&gt;F: Update production plans\n    F-&gt;&gt;F: Calculate production targets\n    F-&gt;&gt;F: Plan purchases\n\n    SE-&gt;&gt;H: Update consumption plans\n    H-&gt;&gt;H: Allocate budgets\n    H-&gt;&gt;H: Plan purchases\n\n    SE-&gt;&gt;C: Update trade flows\n    C-&gt;&gt;C: Process imports/exports\n\n    SE-&gt;&gt;M: Execute transactions\n    M-&gt;&gt;F: Fulfill orders\n    M-&gt;&gt;H: Deliver goods\n    M-&gt;&gt;C: Process trade\n\n    SE-&gt;&gt;SE: Update inventories\n    SE-&gt;&gt;SE: Collect data</code></pre>"},{"location":"architecture/simulation/#production-and-consumption-cycle","title":"Production and Consumption Cycle","text":"<pre><code>def execute_agent_decisions(self, t: int):\n    \"\"\"Execute agent decision-making phase.\"\"\"\n\n    # 1. Firms update production targets\n    self.update_firm_production_plans(t)\n\n    # 2. Households update consumption plans\n    self.update_household_consumption_plans(t)\n\n    # 3. Countries update trade flows\n    self.update_country_trade_plans(t)\n\ndef execute_agent_actions(self, t: int):\n    \"\"\"Execute agent actions phase.\"\"\"\n\n    # 1. Firms place orders with suppliers\n    self.execute_firm_purchasing(t)\n\n    # 2. Households place orders with retailers\n    self.execute_household_purchasing(t)\n\n    # 3. Process and route shipments\n    self.execute_transport_planning(t)\n\n    # 4. Execute production\n    self.execute_firm_production(t)\n\n    # 5. Deliver goods and update inventories\n    self.execute_deliveries(t)\n\ndef update_firm_production_plans(self, t: int):\n    \"\"\"Update production plans for all firms.\"\"\"\n\n    for firm in self.model.agents.firms.values():\n        try:\n            # Update demand forecast\n            firm.update_demand_forecast(t)\n\n            # Check inventory levels\n            firm.update_inventory_targets(t)\n\n            # Set production target\n            firm.set_production_target(t)\n\n            # Update capacity utilization\n            firm.update_capacity_utilization(t)\n\n        except Exception as e:\n            logger.error(f\"Failed to update firm {firm.pid} production plan: {e}\")\n</code></pre>"},{"location":"architecture/simulation/#market-clearing","title":"Market Clearing","text":""},{"location":"architecture/simulation/#supply-demand-matching","title":"Supply-Demand Matching","text":"<pre><code>class MarketClearingMechanism:\n    \"\"\"Handle supply-demand matching and price formation.\"\"\"\n\n    def __init__(self, price_adjustment_rate: float = 0.1):\n        self.price_adjustment_rate = price_adjustment_rate\n        self.market_prices = {}\n        self.excess_demand = {}\n\n    def clear_markets(self, t: int, agents: AgentCollection):\n        \"\"\"Clear all markets and adjust prices.\"\"\"\n\n        # Collect supply and demand by product\n        market_state = self.collect_market_state(agents)\n\n        # Match supply and demand\n        for product, state in market_state.items():\n            self.clear_single_market(product, state, t)\n\n    def clear_single_market(self, product: str, market_state: dict, t: int):\n        \"\"\"Clear individual product market.\"\"\"\n\n        total_supply = market_state['supply']\n        total_demand = market_state['demand']\n        suppliers = market_state['suppliers']\n        buyers = market_state['buyers']\n\n        # Calculate excess demand\n        excess_demand = total_demand - total_supply\n        self.excess_demand[product] = excess_demand\n\n        if excess_demand &gt; 0:\n            # Shortage: ration supply among buyers\n            self.ration_supply(product, suppliers, buyers, total_supply)\n            # Increase price\n            self.adjust_price(product, 1 + self.price_adjustment_rate)\n\n        elif excess_demand &lt; 0:\n            # Surplus: allocate all demand\n            self.allocate_surplus(product, suppliers, buyers, total_demand)\n            # Decrease price\n            self.adjust_price(product, 1 - self.price_adjustment_rate)\n\n        else:\n            # Equilibrium: match exactly\n            self.match_equilibrium(product, suppliers, buyers)\n\n    def ration_supply(self, product: str, suppliers: list, buyers: list, available_supply: float):\n        \"\"\"Ration limited supply among buyers.\"\"\"\n\n        total_demand = sum(buyer.get_demand(product) for buyer in buyers)\n\n        if total_demand &lt;= 0:\n            return\n\n        # Proportional rationing\n        for buyer in buyers:\n            buyer_demand = buyer.get_demand(product)\n            allocated_share = (buyer_demand / total_demand) * available_supply\n            buyer.receive_allocation(product, allocated_share)\n\n        # Allocate supply among suppliers\n        total_supplier_capacity = sum(supplier.get_available_supply(product) for supplier in suppliers)\n\n        for supplier in suppliers:\n            supplier_capacity = supplier.get_available_supply(product)\n            supplier_share = (supplier_capacity / total_supplier_capacity) * available_supply\n            supplier.allocate_production(product, supplier_share)\n</code></pre>"},{"location":"architecture/simulation/#price-formation","title":"Price Formation","text":"<pre><code>class PriceFormation:\n    \"\"\"Handle price formation and adjustment mechanisms.\"\"\"\n\n    def __init__(self, base_prices: dict):\n        self.base_prices = base_prices.copy()\n        self.current_prices = base_prices.copy()\n        self.price_history = {product: [price] for product, price in base_prices.items()}\n\n    def update_prices(self, market_conditions: dict):\n        \"\"\"Update prices based on market conditions.\"\"\"\n\n        for product, conditions in market_conditions.items():\n            # Get current market state\n            excess_demand_ratio = conditions.get('excess_demand_ratio', 0)\n            inventory_levels = conditions.get('inventory_levels', 1.0)\n            competition_factor = conditions.get('competition_factor', 1.0)\n\n            # Calculate price adjustment\n            price_change = self.calculate_price_change(\n                excess_demand_ratio, \n                inventory_levels, \n                competition_factor\n            )\n\n            # Apply adjustment\n            old_price = self.current_prices[product]\n            new_price = old_price * (1 + price_change)\n\n            # Price bounds (prevent extreme prices)\n            min_price = self.base_prices[product] * 0.1\n            max_price = self.base_prices[product] * 10.0\n            new_price = max(min_price, min(max_price, new_price))\n\n            self.current_prices[product] = new_price\n            self.price_history[product].append(new_price)\n\n    def calculate_price_change(self, excess_demand_ratio: float, \n                             inventory_levels: float, \n                             competition_factor: float) -&gt; float:\n        \"\"\"Calculate price change based on market factors.\"\"\"\n\n        # Base adjustment from excess demand\n        demand_adjustment = 0.1 * excess_demand_ratio\n\n        # Inventory adjustment (low inventory -&gt; higher prices)\n        inventory_adjustment = -0.05 * (inventory_levels - 1.0)\n\n        # Competition adjustment (more competition -&gt; lower prices)\n        competition_adjustment = -0.02 * (competition_factor - 1.0)\n\n        total_adjustment = demand_adjustment + inventory_adjustment + competition_adjustment\n\n        # Dampen extreme adjustments\n        return np.tanh(total_adjustment)\n</code></pre>"},{"location":"architecture/simulation/#transport-and-logistics","title":"Transport and Logistics","text":""},{"location":"architecture/simulation/#shipment-planning","title":"Shipment Planning","text":"<pre><code>class LogisticsManager:\n    \"\"\"Manage transport planning and shipment execution.\"\"\"\n\n    def __init__(self, transport_network, routing_algorithm='shortest_path'):\n        self.transport_network = transport_network\n        self.routing_algorithm = routing_algorithm\n        self.shipment_queue = []\n        self.active_shipments = []\n\n    def plan_shipments(self, t: int, purchase_orders: list):\n        \"\"\"Plan shipments for all purchase orders.\"\"\"\n\n        for order in purchase_orders:\n            try:\n                shipment = self.create_shipment(order, t)\n                if shipment:\n                    self.shipment_queue.append(shipment)\n            except Exception as e:\n                logger.error(f\"Failed to plan shipment for order {order.id}: {e}\")\n\n    def create_shipment(self, order: PurchaseOrder, t: int) -&gt; Shipment:\n        \"\"\"Create shipment for purchase order.\"\"\"\n\n        # Get origin and destination\n        origin = order.supplier.transport_node\n        destination = order.buyer.transport_node\n\n        # Calculate route\n        route = self.calculate_route(origin, destination, order.product)\n\n        if not route:\n            logger.warning(f\"No route found from {origin} to {destination}\")\n            return None\n\n        # Calculate transport costs and time\n        transport_cost = self.calculate_transport_cost(route, order.volume)\n        transport_time = self.calculate_transport_time(route, order.product)\n\n        # Create shipment\n        shipment = Shipment(\n            order_id=order.id,\n            route=route,\n            volume=order.volume,\n            value=order.value,\n            product=order.product,\n            departure_time=t,\n            arrival_time=t + transport_time,\n            transport_cost=transport_cost\n        )\n\n        return shipment\n\n    def execute_shipments(self, t: int):\n        \"\"\"Execute shipment movements and deliveries.\"\"\"\n\n        # Start new shipments\n        new_shipments = [s for s in self.shipment_queue if s.departure_time == t]\n        for shipment in new_shipments:\n            self.start_shipment(shipment)\n            self.active_shipments.append(shipment)\n            self.shipment_queue.remove(shipment)\n\n        # Update active shipments\n        completed_shipments = []\n        for shipment in self.active_shipments:\n            shipment.update(t)\n\n            if shipment.is_completed():\n                self.complete_delivery(shipment, t)\n                completed_shipments.append(shipment)\n\n        # Remove completed shipments\n        for shipment in completed_shipments:\n            self.active_shipments.remove(shipment)\n</code></pre>"},{"location":"architecture/simulation/#route-optimization","title":"Route Optimization","text":"<pre><code>class RouteOptimizer:\n    \"\"\"Optimize routes considering multiple factors.\"\"\"\n\n    def __init__(self, transport_network):\n        self.network = transport_network\n        self.route_cache = {}\n\n    def find_optimal_route(self, origin: str, destination: str, \n                          cargo_type: str, preferences: dict) -&gt; list:\n        \"\"\"Find optimal route considering multiple criteria.\"\"\"\n\n        # Check cache\n        cache_key = (origin, destination, cargo_type)\n        if cache_key in self.route_cache:\n            return self.route_cache[cache_key]\n\n        # Get cargo constraints\n        constraints = self.get_cargo_constraints(cargo_type)\n\n        # Generate candidate routes\n        candidates = self.generate_candidate_routes(origin, destination, constraints)\n\n        # Evaluate routes\n        best_route = self.evaluate_routes(candidates, preferences, constraints)\n\n        # Cache result\n        self.route_cache[cache_key] = best_route\n\n        return best_route\n\n    def evaluate_routes(self, candidates: list, preferences: dict, constraints: dict) -&gt; list:\n        \"\"\"Evaluate and select best route from candidates.\"\"\"\n\n        route_scores = []\n\n        for route in candidates:\n            # Calculate route metrics\n            total_cost = self.calculate_route_cost(route)\n            total_time = self.calculate_route_time(route)\n            reliability = self.calculate_route_reliability(route)\n\n            # Check constraints\n            if not self.satisfies_constraints(route, constraints):\n                continue\n\n            # Calculate weighted score\n            score = (\n                preferences.get('cost_weight', 0.4) * (1 / total_cost) +\n                preferences.get('time_weight', 0.4) * (1 / total_time) +\n                preferences.get('reliability_weight', 0.2) * reliability\n            )\n\n            route_scores.append((route, score))\n\n        if not route_scores:\n            return None\n\n        # Return best route\n        route_scores.sort(key=lambda x: x[1], reverse=True)\n        return route_scores[0][0]\n</code></pre>"},{"location":"architecture/simulation/#data-collection","title":"Data Collection","text":""},{"location":"architecture/simulation/#simulation-state","title":"Simulation State","text":"<pre><code>class SimulationState:\n    \"\"\"Track and manage simulation state.\"\"\"\n\n    def __init__(self):\n        self.agent_states = {}\n        self.network_states = {}\n        self.economic_indicators = {}\n        self.disruption_impacts = {}\n        self.convergence_metrics = {}\n\n    def update(self, t: int, model):\n        \"\"\"Update simulation state at time t.\"\"\"\n\n        # Collect agent states\n        self.agent_states[t] = self.collect_agent_states(model.agents)\n\n        # Collect network states\n        self.network_states[t] = self.collect_network_states(model.networks)\n\n        # Calculate economic indicators\n        self.economic_indicators[t] = self.calculate_economic_indicators(model)\n\n        # Assess disruption impacts\n        if hasattr(model, 'disruption_controller'):\n            self.disruption_impacts[t] = self.assess_disruption_impacts(model)\n\n        # Update convergence metrics\n        self.convergence_metrics[t] = self.calculate_convergence_metrics()\n\n    def collect_agent_states(self, agents: AgentCollection) -&gt; dict:\n        \"\"\"Collect current state of all agents.\"\"\"\n\n        state = {\n            'firms': {},\n            'households': {},\n            'countries': {}\n        }\n\n        # Firm states\n        for firm_id, firm in agents.firms.items():\n            state['firms'][firm_id] = {\n                'production': firm.production_current,\n                'production_target': firm.production_target,\n                'inventory': firm.inventory.copy(),\n                'finance': firm.finance,\n                'utilization': firm.capacity_utilization\n            }\n\n        # Household states\n        for hh_id, household in agents.households.items():\n            state['households'][hh_id] = {\n                'consumption': household.consumption_actual.copy(),\n                'consumption_target': household.consumption_targets.copy(),\n                'budget': household.consumption_budget,\n                'satisfaction': household.calculate_satisfaction()\n            }\n\n        # Country states\n        for country_id, country in agents.countries.items():\n            state['countries'][country_id] = {\n                'imports': country.import_flows.copy(),\n                'exports': country.export_flows.copy(),\n                'trade_balance': country.calculate_trade_balance()\n            }\n\n        return state\n</code></pre>"},{"location":"architecture/simulation/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>class PerformanceMonitor:\n    \"\"\"Monitor simulation performance and resource usage.\"\"\"\n\n    def __init__(self):\n        self.start_time = None\n        self.memory_usage = []\n        self.execution_times = {}\n        self.checkpoint_times = {}\n\n    def start(self):\n        \"\"\"Start performance monitoring.\"\"\"\n        self.start_time = time.time()\n        self.memory_usage = []\n\n    def checkpoint(self, name: str):\n        \"\"\"Record performance checkpoint.\"\"\"\n        current_time = time.time()\n        self.checkpoint_times[name] = current_time\n\n        # Record memory usage\n        import psutil\n        memory_mb = psutil.Process().memory_info().rss / 1024 / 1024\n        self.memory_usage.append((current_time - self.start_time, memory_mb))\n\n    def time_function(self, func_name: str, func: callable, *args, **kwargs):\n        \"\"\"Time function execution.\"\"\"\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n\n        if func_name not in self.execution_times:\n            self.execution_times[func_name] = []\n\n        self.execution_times[func_name].append(end_time - start_time)\n\n        return result\n\n    def get_performance_summary(self) -&gt; dict:\n        \"\"\"Get performance summary.\"\"\"\n\n        total_time = time.time() - self.start_time if self.start_time else 0\n        peak_memory = max(memory for _, memory in self.memory_usage) if self.memory_usage else 0\n\n        avg_execution_times = {\n            func_name: np.mean(times) \n            for func_name, times in self.execution_times.items()\n        }\n\n        return {\n            'total_execution_time': total_time,\n            'peak_memory_mb': peak_memory,\n            'average_execution_times': avg_execution_times,\n            'checkpoints': self.checkpoint_times.copy()\n        }\n</code></pre>"},{"location":"architecture/simulation/#convergence-and-equilibrium","title":"Convergence and Equilibrium","text":""},{"location":"architecture/simulation/#convergence-detection","title":"Convergence Detection","text":"<pre><code>class ConvergenceChecker:\n    \"\"\"Check for simulation convergence to equilibrium.\"\"\"\n\n    def __init__(self, tolerance: float = 1e-6, min_steps: int = 10):\n        self.tolerance = tolerance\n        self.min_steps = min_steps\n        self.history_length = 20\n        self.metric_history = {}\n\n    def has_converged(self, simulation_state: SimulationState) -&gt; bool:\n        \"\"\"Check if simulation has converged.\"\"\"\n\n        # Need minimum steps before checking convergence\n        if len(simulation_state.economic_indicators) &lt; self.min_steps:\n            return False\n\n        # Calculate convergence metrics\n        convergence_metrics = self.calculate_convergence_metrics(simulation_state)\n\n        # Check each metric\n        for metric_name, values in convergence_metrics.items():\n            if not self.is_metric_converged(metric_name, values):\n                return False\n\n        return True\n\n    def calculate_convergence_metrics(self, simulation_state: SimulationState) -&gt; dict:\n        \"\"\"Calculate metrics for convergence checking.\"\"\"\n\n        recent_indicators = list(simulation_state.economic_indicators.values())[-self.history_length:]\n\n        metrics = {}\n\n        # Total production convergence\n        total_production = [indicators.get('total_production', 0) for indicators in recent_indicators]\n        metrics['total_production'] = total_production\n\n        # Price convergence\n        if 'average_prices' in recent_indicators[0]:\n            avg_prices = [indicators['average_prices'] for indicators in recent_indicators]\n            metrics['average_prices'] = avg_prices\n\n        # Inventory convergence\n        if 'total_inventory' in recent_indicators[0]:\n            total_inventory = [indicators['total_inventory'] for indicators in recent_indicators]\n            metrics['total_inventory'] = total_inventory\n\n        return metrics\n\n    def is_metric_converged(self, metric_name: str, values: list) -&gt; bool:\n        \"\"\"Check if specific metric has converged.\"\"\"\n\n        if len(values) &lt; 5:  # Need minimum values\n            return False\n\n        # Calculate relative change over last few steps\n        recent_values = values[-5:]\n        relative_changes = []\n\n        for i in range(1, len(recent_values)):\n            if recent_values[i-1] != 0:\n                rel_change = abs((recent_values[i] - recent_values[i-1]) / recent_values[i-1])\n                relative_changes.append(rel_change)\n\n        if not relative_changes:\n            return True\n\n        # Check if all recent changes are below tolerance\n        max_change = max(relative_changes)\n        return max_change &lt; self.tolerance\n</code></pre>"},{"location":"architecture/simulation/#error-handling-and-recovery","title":"Error Handling and Recovery","text":""},{"location":"architecture/simulation/#simulation-recovery","title":"Simulation Recovery","text":"<pre><code>class SimulationRecovery:\n    \"\"\"Handle simulation errors and recovery.\"\"\"\n\n    def __init__(self, checkpoint_interval: int = 10):\n        self.checkpoint_interval = checkpoint_interval\n        self.checkpoints = {}\n        self.error_count = 0\n        self.max_errors = 5\n\n    def save_checkpoint(self, t: int, simulation_state: SimulationState):\n        \"\"\"Save simulation checkpoint.\"\"\"\n\n        if t % self.checkpoint_interval == 0:\n            checkpoint_data = {\n                'time': t,\n                'state': copy.deepcopy(simulation_state),\n                'timestamp': time.time()\n            }\n            self.checkpoints[t] = checkpoint_data\n\n            # Keep only recent checkpoints\n            if len(self.checkpoints) &gt; 10:\n                oldest_time = min(self.checkpoints.keys())\n                del self.checkpoints[oldest_time]\n\n    def handle_simulation_error(self, t: int, error: Exception, simulation: 'Simulation'):\n        \"\"\"Handle simulation error and attempt recovery.\"\"\"\n\n        logger.error(f\"Simulation error at time {t}: {error}\")\n        self.error_count += 1\n\n        if self.error_count &gt; self.max_errors:\n            logger.error(\"Too many errors, terminating simulation\")\n            raise SimulationFailedException(\"Maximum error count exceeded\")\n\n        # Try to recover from checkpoint\n        recovery_time = self.find_recovery_checkpoint(t)\n\n        if recovery_time is not None:\n            logger.info(f\"Recovering from checkpoint at time {recovery_time}\")\n            self.restore_checkpoint(recovery_time, simulation)\n            return recovery_time\n        else:\n            logger.error(\"No suitable checkpoint found for recovery\")\n            raise error\n\n    def restore_checkpoint(self, checkpoint_time: int, simulation: 'Simulation'):\n        \"\"\"Restore simulation from checkpoint.\"\"\"\n\n        checkpoint = self.checkpoints[checkpoint_time]\n        simulation.current_time = checkpoint_time\n        simulation.simulation_state = checkpoint['state']\n\n        # Reset any accumulated errors\n        self.error_count = max(0, self.error_count - 1)\n</code></pre>"},{"location":"architecture/simulation/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"architecture/simulation/#simulation-testing","title":"Simulation Testing","text":"<pre><code>def test_simulation_execution():\n    \"\"\"Test basic simulation execution.\"\"\"\n\n    # Create test model\n    model = create_test_model()\n    parameters = create_test_parameters()\n\n    # Create simulation\n    simulation = Simulation(model, parameters)\n\n    # Run short simulation\n    simulation.max_time = 5\n    simulation.run()\n\n    # Verify execution\n    assert simulation.current_time == 5\n    assert len(simulation.simulation_state.economic_indicators) == 5\n\ndef test_convergence_detection():\n    \"\"\"Test convergence detection.\"\"\"\n\n    checker = ConvergenceChecker(tolerance=1e-6)\n\n    # Create converged state\n    state = SimulationState()\n    for t in range(20):\n        # Stable values\n        state.economic_indicators[t] = {\n            'total_production': 1000.0,\n            'average_prices': 100.0\n        }\n\n    assert checker.has_converged(state)\n\n    # Create non-converged state\n    state2 = SimulationState()\n    for t in range(20):\n        # Changing values\n        state2.economic_indicators[t] = {\n            'total_production': 1000.0 + t * 10,\n            'average_prices': 100.0 + t * 5\n        }\n\n    assert not checker.has_converged(state2)\n</code></pre>"},{"location":"architecture/simulation/#future-enhancements","title":"Future Enhancements","text":""},{"location":"architecture/simulation/#planned-simulation-features","title":"Planned Simulation Features","text":"<ol> <li>Parallel Simulation - Multi-threaded agent updates</li> <li>Adaptive Time Steps - Variable time resolution during simulation</li> <li>Real-Time Simulation - Integration with live data feeds</li> <li>Interactive Simulation - User intervention during execution</li> </ol>"},{"location":"architecture/simulation/#advanced-simulation-capabilities","title":"Advanced Simulation Capabilities","text":"<ol> <li>Machine Learning Integration - AI-driven agent behaviors</li> <li>Uncertainty Quantification - Probabilistic simulation outcomes</li> <li>Multi-Scale Modeling - Integration of different temporal scales</li> <li>Distributed Simulation - Cloud-based parallel execution</li> </ol>"},{"location":"contact/","title":"\ud83e\udd1d Get Involved!","text":"<p>DisruptSC has a growing network of contributors and users. You are very welcomed to join!</p>"},{"location":"contact/#licensing","title":"\ud83d\udcdc Licensing","text":"<p>The model is published under CC BY-NC-ND 4.0, which implies:</p> <ul> <li>\u2705 Free sharing, modification, and reuse, provided you credit the lead author  </li> <li>\ud83d\udeab No commercial application (see below)  </li> <li>\u26a0\ufe0f You cannot transform the model and re-distribute it with your own license  </li> </ul>"},{"location":"contact/#research-collaboration","title":"\ud83d\udd2c Research Collaboration","text":"<p>To discuss research collaborations, please contact the lead author directly.</p>"},{"location":"contact/#commercial-applications","title":"\ud83d\udcbc Commercial Applications","text":"<p>For any commercial applications of the model, please contact the lead author directly.</p>"},{"location":"contributors/","title":"Contributors","text":""},{"location":"contributors/#lead-author","title":"\ud83e\uddd1\u200d\ud83d\udd2c Lead Author","text":"Celian Colon, IIASA ORCID Google Scholar GitHub     celian.colon[at]polytechnique[dot]org"},{"location":"contributors/#contributors_1","title":"\ud83e\udd1d Contributors","text":"<p>Writing in progress.</p>"},{"location":"contributors/#funders","title":"\ud83c\udfdb\ufe0f Funders","text":""},{"location":"contributors/releases/","title":"Release Management","text":"<p>This document explains how the automated release workflow works for DisruptSC.</p>"},{"location":"contributors/releases/#overview","title":"Overview","text":"<p>DisruptSC uses an automated release system that:</p> <ul> <li>Frequent Development: Push code changes frequently without version updates</li> <li>Automated Releases: When version is incremented, automatically create GitHub releases</li> <li>Documentation Updates: Version appears in MkDocs and README automatically</li> <li>Version Management: Single source of truth in <code>src/disruptsc/_version.py</code></li> </ul>"},{"location":"contributors/releases/#workflow","title":"Workflow","text":""},{"location":"contributors/releases/#development-frequent-pushes","title":"Development (Frequent Pushes)","text":"<p>For regular development work:</p> <ol> <li>Make code changes as usual</li> <li>Push to main branch frequently</li> <li>Documentation deploys automatically (latest version)</li> <li>No version increment needed</li> </ol> <pre><code># Regular development workflow\ngit add .\ngit commit -m \"fix: improve error handling in transport network\"\ngit push origin main\n\n# Documentation automatically updates at https://ccolon.github.io/disrupt-sc/\n</code></pre>"},{"location":"contributors/releases/#creating-a-release","title":"Creating a Release","text":"<p>When ready to create a formal release:</p> <ol> <li>Update version in <code>src/disruptsc/_version.py</code></li> <li>Optionally create custom release notes (see Release Notes Control below)</li> <li>Push to main branch</li> <li>Automation handles the rest</li> </ol> <pre><code># 1. Update version\necho '__version__ = \"1.2.0\"' &gt; src/disruptsc/_version.py\n\n# 2. Commit and push\ngit add src/disruptsc/_version.py\ngit commit -m \"release: bump version to 1.2.0\"\ngit push origin main\n\n# 3. Automation creates:\n# - GitHub release with tag v1.2.0\n# - Updated documentation with version 1.2.0\n# - Version badge in README.md\n# - Release notes (auto-generated or custom)\n</code></pre>"},{"location":"contributors/releases/#what-happens-automatically","title":"What Happens Automatically","text":"<p>When you increment the version number, the GitHub Actions workflow:</p>"},{"location":"contributors/releases/#1-detects-version-change","title":"1. Detects Version Change","text":"<ul> <li>Compares current version with previous commit</li> <li>Only triggers release workflow if version changed</li> </ul>"},{"location":"contributors/releases/#2-creates-github-release","title":"2. Creates GitHub Release","text":"<ul> <li>Tag: <code>v{version}</code> (e.g., <code>v1.2.0</code>)</li> <li>Release notes: Auto-generated from commit messages since last release</li> <li>Installation instructions: Updated with new version</li> </ul>"},{"location":"contributors/releases/#3-updates-documentation","title":"3. Updates Documentation","text":"<ul> <li>MkDocs: Deploys version-specific documentation</li> <li>Version display: Shows current version on documentation pages</li> <li>Version selector: Available in documentation sidebar</li> </ul>"},{"location":"contributors/releases/#4-updates-repository","title":"4. Updates Repository","text":"<ul> <li>README badge: Version badge automatically updated</li> <li>Git tags: Version tag created and pushed</li> </ul>"},{"location":"contributors/releases/#version-numbering","title":"Version Numbering","text":"<p>Use Semantic Versioning:</p> <ul> <li>MAJOR: Incompatible API changes (<code>2.0.0</code>)</li> <li>MINOR: New functionality, backwards compatible (<code>1.1.0</code>)</li> <li>PATCH: Bug fixes, backwards compatible (<code>1.0.1</code>)</li> </ul> <pre><code># Examples of version updates\n__version__ = \"1.0.1\"  # Bug fix\n__version__ = \"1.1.0\"  # New feature\n__version__ = \"2.0.0\"  # Breaking change\n</code></pre>"},{"location":"contributors/releases/#documentation-versioning","title":"Documentation Versioning","text":"<p>Documentation is managed with mike:</p> <ul> <li>Latest: Always points to newest version</li> <li>Version-specific: Each release gets its own documentation</li> <li>Navigation: Version selector in documentation</li> </ul>"},{"location":"contributors/releases/#available-documentation-versions","title":"Available Documentation Versions","text":"<ul> <li>Latest: <code>https://ccolon.github.io/disrupt-sc/</code> (default)</li> <li>Specific: <code>https://ccolon.github.io/disrupt-sc/1.2.0/</code></li> <li>Version list: Available in documentation version selector</li> </ul>"},{"location":"contributors/releases/#manual-operations","title":"Manual Operations","text":""},{"location":"contributors/releases/#creating-pre-releases","title":"Creating Pre-releases","text":"<p>For beta or release candidate versions:</p> <pre><code># Update to pre-release version\necho '__version__ = \"1.2.0-beta1\"' &gt; src/disruptsc/_version.py\ngit add src/disruptsc/_version.py\ngit commit -m \"release: 1.2.0-beta1\"\ngit push origin main\n\n# Manually mark as pre-release in GitHub UI if needed\n</code></pre>"},{"location":"contributors/releases/#manual-documentation-deployment","title":"Manual Documentation Deployment","text":"<p>If needed, you can manually deploy documentation:</p> <pre><code># Install requirements\npip install -r docs-requirements.txt\npip install mike\n\n# Deploy specific version\nmike deploy --push --update-aliases 1.2.0 latest\n\n# Set as default\nmike set-default --push latest\n</code></pre>"},{"location":"contributors/releases/#emergency-release-fix","title":"Emergency Release Fix","text":"<p>If automation fails:</p> <pre><code># Create tag manually\ngit tag v1.2.0\ngit push origin v1.2.0\n\n# Create release manually on GitHub\n# Deploy docs manually (see above)\n</code></pre>"},{"location":"contributors/releases/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributors/releases/#release-workflow-not-triggered","title":"Release Workflow Not Triggered","text":"<p>Problem: Version changed but no release created</p> <p>Solution: Check GitHub Actions logs <pre><code># Check if workflow ran\n# Go to: https://github.com/ccolon/disrupt-sc/actions\n\n# Common issues:\n# - Workflow file syntax error\n# - Permission issues\n# - Version format invalid\n</code></pre></p>"},{"location":"contributors/releases/#documentation-not-updated","title":"Documentation Not Updated","text":"<p>Problem: Documentation doesn't show new version</p> <p>Solution:  <pre><code># Check docs-requirements.txt has mkdocs-macros-plugin\n# Check docs/main.py exists and is correct\n# Check MkDocs configuration includes macros plugin\n</code></pre></p>"},{"location":"contributors/releases/#version-badge-not-updated","title":"Version Badge Not Updated","text":"<p>Problem: README badge shows old version</p> <p>Solution: Workflow should auto-update, but manual fix: <pre><code># Update badge manually\nsed -i 's/version-[0-9.]*/version-1.2.0/' README.md\ngit add README.md\ngit commit -m \"docs: update version badge\"\ngit push origin main\n</code></pre></p>"},{"location":"contributors/releases/#release-notes-control","title":"Release Notes Control","text":"<p>You have multiple options to control release notes, from fully automated to completely custom:</p>"},{"location":"contributors/releases/#option-1-automatic-release-notes-default","title":"Option 1: Automatic Release Notes (Default)","text":"<p>By default, release notes are auto-generated from commit messages with categorization:</p> <ul> <li>\u2728 New Features: Commits starting with <code>feat:</code></li> <li>\ud83d\udc1b Bug Fixes: Commits starting with <code>fix:</code></li> <li>\ud83d\udcda Documentation: Commits starting with <code>docs:</code></li> <li>\ud83d\udd27 Other Changes: All other commits</li> </ul>"},{"location":"contributors/releases/#option-2-custom-release-notes-pre-release","title":"Option 2: Custom Release Notes (Pre-Release)","text":"<p>Create a <code>RELEASE_NOTES.md</code> file before incrementing the version:</p> <pre><code># 1. Create custom release notes\ncat &gt; RELEASE_NOTES.md &lt;&lt; 'EOF'\n# Release Notes for v{{ VERSION }}\n\n## \ud83d\ude80 Major Features\n\n- **New simulation type**: Added sensitivity analysis with parameter sweeps\n- **Memory management**: Resolved memory leaks in Monte Carlo simulations\n- **Performance improvements**: 40% faster route calculations\n\n## \ud83d\udd27 Technical Changes\n\n- Unified AdHocExecutor classes to reduce code duplication\n- Enhanced input validation with comprehensive error reporting\n- Updated documentation with new simulation types\n\n## \ud83d\udc1b Bug Fixes\n\n- Fixed inventory parameter setting in sensitivity analysis\n- Resolved transport network caching issues\n- Corrected country loss calculation edge cases\n\n## \u26a0\ufe0f Breaking Changes\n\nNone in this release.\n\n## \ud83d\udce6 Migration Guide\n\nNo migration needed - all changes are backwards compatible.\nEOF\n\n# 2. Update version and push together\necho '__version__ = \"1.2.0\"' &gt; src/disruptsc/_version.py\ngit add RELEASE_NOTES.md src/disruptsc/_version.py\ngit commit -m \"release: version 1.2.0 with custom release notes\"\ngit push origin main\n\n# 3. Automation uses your custom notes and cleans up the file\n</code></pre> <p>Template placeholders: - <code>{{ VERSION }}</code> - Automatically replaced with actual version number</p>"},{"location":"contributors/releases/#option-3-edit-after-release-manual","title":"Option 3: Edit After Release (Manual)","text":"<p>Edit the release on GitHub after it's created:</p> <ol> <li>Release created automatically with basic notes</li> <li>Go to GitHub: <code>https://github.com/ccolon/disrupt-sc/releases</code></li> <li>Click \"Edit release\" on the new release</li> <li>Rewrite the description as needed</li> <li>Save changes</li> </ol>"},{"location":"contributors/releases/#option-4-release-drafts","title":"Option 4: Release Drafts","text":"<p>Modify the workflow to create draft releases:</p> <pre><code># In .github/workflows/release.yml, change:\ndraft: true  # Instead of false\n</code></pre> <p>Then manually review and publish each release.</p>"},{"location":"contributors/releases/#best-practices","title":"Best Practices","text":""},{"location":"contributors/releases/#commit-messages","title":"Commit Messages","text":"<p>Use conventional commits for better automatic release notes:</p> <pre><code># Good commit messages for release notes\ngit commit -m \"feat: add sensitivity analysis simulation type\"\ngit commit -m \"fix: resolve memory leak in monte carlo executor\"  \ngit commit -m \"docs: update parameter documentation\"\ngit commit -m \"refactor: simplify transport network setup\"\n</code></pre>"},{"location":"contributors/releases/#custom-release-notes-template","title":"Custom Release Notes Template","text":"<p>Save this template for consistent custom release notes:</p> <pre><code># Release Notes for v{{ VERSION }}\n\n## \ud83d\ude80 What's New\n\n[Highlight major features and improvements]\n\n## \ud83d\udd27 Technical Changes\n\n[Detail technical improvements, refactoring, etc.]\n\n## \ud83d\udc1b Bug Fixes\n\n[List important bug fixes]\n\n## \u26a0\ufe0f Breaking Changes\n\n[Note any breaking changes or \"None in this release\"]\n\n## \ud83d\udce6 Migration Guide\n\n[Provide migration steps or \"No migration needed\"]\n\n## \ud83d\ude4f Contributors\n\n[Thank contributors if applicable]\n</code></pre>"},{"location":"contributors/releases/#release-timing","title":"Release Timing","text":"<ul> <li>Patch releases: As needed for bug fixes</li> <li>Minor releases: Monthly or when significant features ready</li> <li>Major releases: Quarterly or for breaking changes</li> </ul>"},{"location":"contributors/releases/#version-strategy","title":"Version Strategy","text":"<pre><code># Development cycle example:\n1.0.0 -&gt; 1.0.1 -&gt; 1.0.2 -&gt; 1.1.0 -&gt; 1.1.1 -&gt; 2.0.0\n\n# Pre-release testing:\n1.1.0-beta1 -&gt; 1.1.0-beta2 -&gt; 1.1.0-rc1 -&gt; 1.1.0\n</code></pre>"},{"location":"contributors/releases/#related-files","title":"Related Files","text":"<p>Key files in the release system:</p> <ul> <li><code>src/disruptsc/_version.py</code> - Single source of truth for version</li> <li><code>.github/workflows/release.yml</code> - Automated release workflow</li> <li><code>docs/main.py</code> - MkDocs macros for version display</li> <li><code>docs-requirements.txt</code> - Documentation dependencies</li> <li><code>mkdocs.yml</code> - Documentation configuration with versioning</li> <li><code>README.md</code> - Contains version badge</li> </ul>"},{"location":"contributors/releases/#monitoring","title":"Monitoring","text":"<p>Monitor the release system:</p> <ul> <li>GitHub Actions: Check workflow success/failure</li> <li>Documentation: Verify version appears correctly</li> <li>Releases: Check GitHub releases page</li> <li>Tags: Verify git tags created properly</li> </ul> <p>The automation handles most release tasks, allowing you to focus on development while maintaining professional release management.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to DisruptSC! This section will help you get up and running with the model quickly.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Python 3.10 or 3.11 installed</li> <li>Git for repository management</li> <li>Access to input data (see Data Setup)</li> </ul>"},{"location":"getting-started/#setup-process","title":"Setup Process","text":"<p>Follow these steps to get DisruptSC running on your system:</p> <ol> <li>Installation - Set up the environment and dependencies</li> <li>Data Setup - Configure input data sources  </li> <li>Quick Start - Run your first simulation</li> <li>Input Validation - Verify your data is correctly formatted</li> </ol>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<p>After completing the setup:</p> <ul> <li>Explore the User Guide for detailed usage instructions</li> <li>Learn more about Parameters to customize your simulations</li> <li>Read about the Architecture to understand how the model works</li> </ul>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":"Environment setup problems <p>If you encounter issues with conda environment creation, try:</p> <pre><code># Clear conda cache\nconda clean --all\n\n# Create environment with explicit solver\nconda env create -f dsc-environment.yml --solver=libmamba\n</code></pre> Data path not found <p>Make sure your data path is correctly set:</p> <pre><code># Check if environment variable is set\necho $DISRUPT_SC_DATA_PATH\n\n# Or verify data folder exists\nls -la data/\n</code></pre> Import errors when running <p>Ensure you've installed the package in development mode:</p> <pre><code>conda activate dsc\npip install -e .\n</code></pre>"},{"location":"getting-started/data-setup/","title":"Data Setup","text":"<p>DisruptSC requires input data to run simulations. This guide explains how to set up your data sources.</p>"},{"location":"getting-started/data-setup/#repository-separation","title":"Repository Separation","text":"<p>The model code and data are maintained in separate repositories:</p> <ul> <li>disrupt-sc (public) - Model code, configuration, documentation</li> <li>disrupt-sc-data (private) - Input data files</li> </ul> <p>This separation allows for: - Public sharing of the model code - Secure handling of sensitive economic data - Flexible data source configuration</p>"},{"location":"getting-started/data-setup/#data-setup-options","title":"Data Setup Options","text":"<p>Choose one of the following methods to provide input data:</p>"},{"location":"getting-started/data-setup/#option-1-git-submodule-recommended","title":"Option 1: Git Submodule (Recommended)","text":"<p>If you have access to the private data repository, the submodule should be automatically set up when you clone:</p> <pre><code># If you cloned with --recurse-submodules, data is already available\nls data/  # Should show: Cambodia, ECA, Ecuador, etc.\n\n# If data folder is empty, initialize the submodule\ngit submodule update --init --recursive\n\n# Update data to latest version\ngit submodule update --remote data\n</code></pre> <p>Common Submodule Issues</p> <ul> <li>Empty data folder: Run <code>git submodule update --init --recursive</code></li> <li>\"Already exists\" error: Don't run <code>git submodule add</code> again, just update existing submodule</li> <li>New computer setup: Always use <code>git clone --recurse-submodules</code> or initialize submodules after cloning</li> </ul> <p>Advantages: - Version-controlled data - Automatic updates with git - Collaborative data management</p>"},{"location":"getting-started/data-setup/#option-2-local-input-folder-simple","title":"Option 2: Local Input Folder (Simple)","text":"<p>Create a local <code>input/</code> folder:</p> <pre><code># Create input directory\nmkdir input\n\n# Copy your data files following the structure below\n# input/Cambodia/Economic/mrio.csv\n# input/Cambodia/Transport/roads_edges.geojson\n# etc.\n</code></pre> <p>Advantages: - Simple setup - No external dependencies - Good for testing</p>"},{"location":"getting-started/data-setup/#data-path-priority","title":"Data Path Priority","text":"<p>DisruptSC automatically detects data location in this order:</p> <ol> <li><code>data/</code> folder (git submodule, highest priority)</li> <li><code>input/</code> folder (local fallback)</li> </ol>"},{"location":"getting-started/data-setup/#required-data-structure","title":"Required Data Structure","text":"<p>Input data must be organized by scope (region):</p> <pre><code>data/{scope}/               # e.g., data/Cambodia/\n\u251c\u2500\u2500 Economic/               # Economic data\n\u2502   \u251c\u2500\u2500 mrio.csv           # Multi-regional input-output table\n\u2502   \u2514\u2500\u2500 sector_table.csv   # Sector definitions and parameters\n\u251c\u2500\u2500 Transport/              # Infrastructure networks\n\u2502   \u251c\u2500\u2500 roads_edges.geojson          # Road network (LineString)\n\u2502   \u251c\u2500\u2500 maritime_edges.geojson       # Maritime routes (LineString) \n\u2502   \u251c\u2500\u2500 railways_edges.geojson       # Railway network (LineString)\n\u2502   \u251c\u2500\u2500 airways_edges.geojson        # Air routes (LineString)\n\u2502   \u251c\u2500\u2500 waterways_edges.geojson      # Waterway network (LineString)\n\u2502   \u251c\u2500\u2500 pipelines_edges.geojson      # Pipeline network (LineString)\n\u2502   \u2514\u2500\u2500 multimodal_edges.geojson     # Multimodal connections\n\u2514\u2500\u2500 Spatial/                # Geographic disaggregation\n    \u251c\u2500\u2500 households.geojson           # Household locations (Point)\n    \u251c\u2500\u2500 countries.geojson            # Country entry points (Point)\n    \u2514\u2500\u2500 firms.geojson                # Firm spatial distribution (Point)\n</code></pre>"},{"location":"getting-started/data-setup/#scope-configuration","title":"Scope Configuration","text":"<p>Each scope requires:</p> <ol> <li>Data folder: <code>data/{scope}/</code> or <code>input/{scope}/</code></li> <li>Parameter file: <code>parameter/user_defined_{scope}.yaml</code></li> </ol> <p>For example, to set up Cambodia: - Data: <code>data/Cambodia/</code> - Parameters: <code>parameter/user_defined_Cambodia.yaml</code></p>"},{"location":"getting-started/data-setup/#file-requirements","title":"File Requirements","text":""},{"location":"getting-started/data-setup/#essential-files-always-required","title":"Essential Files (Always Required)","text":"<ul> <li><code>Economic/mrio.csv</code> - Input-output table</li> <li><code>Economic/sector_table.csv</code> - Sector definitions</li> <li><code>Transport/roads_edges.geojson</code> - Road network</li> <li><code>Spatial/households.geojson</code> - Household locations</li> </ul>"},{"location":"getting-started/data-setup/#transport-networks","title":"Transport Networks","text":"<p>At minimum, roads are required. Additional transport modes are optional: - Maritime (international trade) - Railways (freight transport) - Airways (high-value goods) - Waterways (bulk transport) - Pipelines (energy/chemicals)</p>"},{"location":"getting-started/data-setup/#data-modes","title":"Data Modes","text":"<p>Different data requirements based on mode:</p> <p>MRIO Mode (Default)</p> <p>Required: - <code>Economic/mrio.csv</code> - <code>Economic/sector_table.csv</code> - <code>Spatial/*.geojson</code> files</p> <p>Generated: Firms, households, countries from MRIO data</p> <p>Supplier-Buyer Network Mode</p> <p>Additional Requirements: - <code>Economic/firm_table.csv</code> - <code>Economic/location_table.csv</code> - <code>Economic/transaction_table.csv</code></p> <p>Use case: When you have detailed firm-level data</p>"},{"location":"getting-started/data-setup/#verification","title":"Verification","text":"<p>After setting up your data, verify the configuration:</p> <pre><code># Check data path detection\npython -c \"from disruptsc.paths import get_data_path; print(get_data_path('Cambodia'))\"\n\n# Validate input files\npython validate_inputs.py Cambodia\n\n# Test basic model initialization\npython disruptsc/main.py Cambodia --help\n</code></pre>"},{"location":"getting-started/data-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/data-setup/#data-path-issues","title":"Data Path Issues","text":"Data path not found <pre><code># Verify folder exists\nls -la data/Cambodia/\nls -la input/Cambodia/\n\n# Check folder permissions\nls -la data/\n</code></pre> Git submodule problems <pre><code># Most common issue: initialize submodules\ngit submodule update --init --recursive\n\n# Check submodule status\ngit submodule status\n\n# If completely broken, reset submodule (last resort)\ngit submodule deinit data\ngit rm data\ngit submodule add &lt;data-repository-url&gt; data\ngit submodule update --init --recursive\n</code></pre>"},{"location":"getting-started/data-setup/#file-format-issues","title":"File Format Issues","text":"Invalid file formats <ul> <li>Ensure CSV files use UTF-8 encoding</li> <li>GeoJSON files must have valid geometry</li> <li>LineString required for transport edges</li> <li>Point geometry required for spatial locations</li> </ul> Missing required columns <p>Run the input validator for detailed error messages: <pre><code>python validate_inputs.py Cambodia\n</code></pre></p>"},{"location":"getting-started/data-setup/#whats-next","title":"What's Next?","text":"<p>After setting up your data:</p> <ol> <li>Validate inputs - Check data quality</li> <li>Run quick start - Test your setup</li> <li>Configure parameters - Customize simulation settings</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install DisruptSC and set up the required environment.</p>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: 3.10 or 3.11 (required)</li> <li>Operating System: Windows, macOS, or Linux</li> <li>Memory: Minimum 8GB RAM (16GB+ recommended for large models)</li> <li>Storage: 5GB+ free space for data and outputs</li> </ul>"},{"location":"getting-started/installation/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<p>The DisruptSC project uses Git submodules to manage data separately from the main codebase. Choose one of the following methods:</p>"},{"location":"getting-started/installation/#method-a-clone-with-submodules-recommended","title":"Method A: Clone with Submodules (Recommended)","text":"<pre><code># Clone repository and initialize submodules in one step\ngit clone --recurse-submodules https://github.com/worldbank/disrupt-sc.git\ncd disrupt-sc\n</code></pre>"},{"location":"getting-started/installation/#method-b-clone-then-initialize-submodules","title":"Method B: Clone then Initialize Submodules","text":"<pre><code># Clone repository\ngit clone https://github.com/ccolon/disrupt-sc.git\ncd disrupt-sc\n\n# Initialize and update data submodule\ngit submodule update --init --recursive\n</code></pre> <p>About Data Submodules</p> <p>DisruptSC uses a separate private repository for input data to keep the main codebase lightweight. The data is automatically linked as a Git submodule in the <code>data/</code> folder.</p>"},{"location":"getting-started/installation/#step-2-environment-setup","title":"Step 2: Environment Setup","text":"<p>We recommend using Conda for environment management to ensure reproducible installations.</p>"},{"location":"getting-started/installation/#option-a-conda-environment-recommended","title":"Option A: Conda Environment (Recommended)","text":"<pre><code># Create environment from file\nconda env create -f dsc-environment.yml\n\n# Activate environment\nconda activate dsc\n\n# Install package in development mode\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#option-b-pip-installation","title":"Option B: Pip Installation","text":"<p>If you prefer using pip or don't have Conda installed:</p> <pre><code># Create virtual environment\npython -m venv dsc-env\n\n# Activate environment\n# On Windows:\ndsc-env\\Scripts\\activate\n# On macOS/Linux:\nsource dsc-env/bin/activate\n\n# Install dependencies\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#step-3-verify-installation","title":"Step 3: Verify Installation","text":"<p>Test that DisruptSC is correctly installed:</p> <pre><code># Check version\npython -c \"import disruptsc; print(disruptsc.__version__)\"\n\n# Test CLI\npython src/disruptsc/main.py --version\n# Or use the installed script:\ndisruptsc --version\n\n# Run input validation (requires data setup)\npython scripts/validate_inputs.py --help\n# Or use the installed script:\nvalidate-inputs --help\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>DisruptSC relies on several key packages:</p>"},{"location":"getting-started/installation/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>pandas - Data manipulation and analysis</li> <li>numpy - Numerical computing</li> <li>geopandas - Geospatial data processing</li> <li>networkx - Graph/network analysis</li> <li>scipy - Scientific computing</li> <li>shapely - Geometric operations</li> </ul>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>matplotlib - Basic plotting</li> <li>plotly - Interactive visualizations</li> <li>jupyter - Notebook environment for analysis</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-installation-issues","title":"Common Installation Issues","text":"Empty data folder after cloning <p>If your <code>data/</code> folder is empty after cloning, the submodule wasn't initialized:</p> <pre><code># Initialize and update submodules\ngit submodule update --init --recursive\n\n# Verify data is present\nls data/\n# Should show: Cambodia, ECA, Ecuador, Global, Testkistan, etc.\n</code></pre> Submodule already exists error <p>If you get <code>fatal: 'data' already exists in the index</code> when trying to add submodules:</p> <pre><code># The submodule is already configured, just update it\ngit submodule update --init --recursive\n\n# Don't run git submodule add again\n</code></pre> Conda environment creation hangs <p>The environment creation may get stuck in the \"solving environment\" step. Try:</p> <pre><code># Clear conda cache\nconda clean --all\n\n# Use libmamba solver (faster)\nconda install -n base conda-libmamba-solver\nconda config --set solver libmamba\n\n# Retry environment creation\nconda env create -f dsc-environment.yml\n</code></pre> Geospatial package installation fails <p>GeoPandas and related packages can be tricky to install. Solutions:</p> <pre><code># Install from conda-forge (recommended)\nconda install -c conda-forge geopandas\n\n# Or use mamba (faster conda alternative)\nmamba install geopandas\n</code></pre> Import errors after installation <p>If you get import errors when running DisruptSC:</p> <pre><code># Make sure environment is activated\nconda activate dsc\n\n# Reinstall in development mode\npip install -e .\n\n# Check Python path\npython -c \"import sys; print(sys.path)\"\n</code></pre>"},{"location":"getting-started/installation/#environment-issues","title":"Environment Issues","text":"<p>If you encounter environment conflicts:</p> <pre><code># Remove existing environment\nconda env remove -n dsc\n\n# Recreate clean environment\nconda env create -f dsc-environment.yml\n\n# Alternative: create minimal environment and install manually\nconda create -n dsc python=3.11\nconda activate dsc\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For developers contributing to DisruptSC:</p> <pre><code># Clone with development dependencies and submodules\ngit clone --recurse-submodules https://github.com/worldbank/disrupt-sc.git\ncd disrupt-sc\n\n# Create development environment\nconda env create -f dsc-environment.yml\nconda activate dsc\n\n# Install in development mode with test dependencies\npip install -e \".[dev,test]\"\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"getting-started/installation/#whats-next","title":"What's Next?","text":"<p>After successful installation:</p> <ol> <li>Set up your data sources - Configure input data</li> <li>Run the quick start example - Test your installation</li> <li>Validate your inputs - Ensure data quality</li> </ol>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you're still having trouble:</p> <ul> <li>Review the common issues above</li> <li>Search existing issues</li> <li>Open a new issue with your error message and system details</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will get you running your first DisruptSC simulation in just a few minutes.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>\u2705 Installed DisruptSC</li> <li>\u2705 Set up your data sources</li> <li>\u2705 Activated the conda environment: <code>conda activate dsc</code></li> </ul>"},{"location":"getting-started/quick-start/#available-regions","title":"Available Regions","text":"<p>DisruptSC comes with several pre-configured regions:</p> Region Description Scale Use Case Cambodia Southeast Asian economy National Regional trade analysis ECA Europe &amp; Central Asia Multi-country Cross-border impacts Ecuador South American economy National Natural disaster studies Global World economy International Global supply chains Testkistan Synthetic test case Small Learning and testing"},{"location":"getting-started/quick-start/#your-first-simulation","title":"Your First Simulation","text":""},{"location":"getting-started/quick-start/#step-1-validate-your-data","title":"Step 1: Validate Your Data","text":"<p>Before running simulations, validate your input data:</p> <pre><code># Validate inputs for Cambodia\npython validate_inputs.py Cambodia\n</code></pre> <p>You should see: <pre><code>\u2705 Validation successful for Cambodia\nAll required files found and validated\nReady to run simulations\n</code></pre></p>"},{"location":"getting-started/quick-start/#step-2-run-basic-simulation","title":"Step 2: Run Basic Simulation","text":"<p>Start with an initial state analysis:</p> <pre><code># Run baseline simulation for Cambodia\npython disruptsc/main.py Cambodia\n</code></pre> <p>This will:</p> <ol> <li>Setup transport network - Load roads, maritime, and other infrastructure</li> <li>Create agents - Generate firms, households, and countries</li> <li>Build supply chains - Connect buyers and suppliers</li> <li>Optimize routes - Find efficient transport paths</li> <li>Initialize equilibrium - Set baseline economic conditions</li> <li>Run simulation - Execute the model and collect results</li> </ol>"},{"location":"getting-started/quick-start/#step-3-check-results","title":"Step 3: Check Results","text":"<p>Results are saved in timestamped folders:</p> <pre><code># Navigate to results\nls output/Cambodia/\n\n# View the latest results\ncd output/Cambodia/$(ls -t output/Cambodia/ | head -1)\nls -la\n</code></pre> <p>Key output files: - <code>firm_data.json</code> - Firm state over time - <code>household_data.json</code> - Household consumption patterns - <code>transport_edges_with_flows_0.geojson</code> - Transport flows visualization - <code>parameters.yaml</code> - Configuration used for this run - <code>exp.log</code> - Detailed execution log</p>"},{"location":"getting-started/quick-start/#advanced-usage","title":"Advanced Usage","text":""},{"location":"getting-started/quick-start/#simulation-types","title":"Simulation Types","text":"<p>Configure different simulation types in your parameter file:</p> <pre><code># parameter/user_defined_Cambodia.yaml\nsimulation_type: \"initial_state\"  # Options below\n</code></pre> <p>Available simulation types:</p> Type Purpose When to Use <code>initial_state</code> Baseline equilibrium Understanding normal operations <code>disruption</code> Single disruption scenario Testing specific events <code>criticality</code> Infrastructure assessment Finding critical links <code>flow_calibration</code> Transport calibration Matching observed data"},{"location":"getting-started/quick-start/#monte-carlo-simulations","title":"Monte Carlo Simulations","text":"<p>Control Monte Carlo runs with the <code>mc_repetitions</code> parameter:</p> <pre><code># In parameter file\nmc_repetitions: 10               # Run 10 iterations\nsimulation_type: \"disruption\"    # Base simulation type\n</code></pre> <p>Behavior: - <code>mc_repetitions = 0</code>: Single run with full output files - <code>mc_repetitions \u2265 1</code>: Multiple runs with CSV summary only</p>"},{"location":"getting-started/quick-start/#caching-for-performance","title":"Caching for Performance","text":"<p>Speed up repeated runs with caching:</p> <pre><code># First run (builds everything)\npython disruptsc/main.py Cambodia\n\n# Reuse transport network, rebuild agents\npython disruptsc/main.py Cambodia --cache same_transport_network_new_agents\n\n# Reuse agents, rebuild supply chains\npython disruptsc/main.py Cambodia --cache same_agents_new_sc_network\n\n# Reuse supply chains, rebuild routes\npython disruptsc/main.py Cambodia --cache same_sc_network_new_logistic_routes\n\n# Reuse everything\npython disruptsc/main.py Cambodia --cache same_logistic_routes\n</code></pre>"},{"location":"getting-started/quick-start/#custom-parameters","title":"Custom Parameters","text":"<p>Override default parameters:</p> <pre><code># Run with custom duration and cutoffs\npython disruptsc/main.py Cambodia --duration 90 --io_cutoff 0.5\n\n# See all available options\npython disruptsc/main.py Cambodia --help\n</code></pre>"},{"location":"getting-started/quick-start/#disruption-scenarios","title":"Disruption Scenarios","text":""},{"location":"getting-started/quick-start/#simple-transport-disruption","title":"Simple Transport Disruption","text":"<p>Create a basic disruption scenario by editing your parameter file:</p> <pre><code># parameter/user_defined_Cambodia.yaml\nsimulation_type: \"disruption\"\n\nevents:\n  - type: \"transport_disruption\"\n    description_type: \"edge_attributes\"\n    attribute: \"highway_type\"\n    value: [\"primary\"]\n    start_time: 10\n    duration: 20\n</code></pre> <p>This disrupts primary highways from time step 10 for 20 time steps.</p>"},{"location":"getting-started/quick-start/#capital-destruction-event","title":"Capital Destruction Event","text":"<p>Model economic impacts of disasters:</p> <pre><code>events:\n  - type: \"capital_destruction\"\n    description_type: \"region_sector_file\"\n    region_sector_filepath: \"Disruption/earthquake_damage.csv\"\n    unit: \"mUSD\"\n    reconstruction_market: true\n    start_time: 5\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-results","title":"Understanding Results","text":""},{"location":"getting-started/quick-start/#economic-impacts","title":"Economic Impacts","text":"<p>Key metrics to analyze:</p> <ul> <li>Production losses - Reduced output by firms</li> <li>Consumption losses - Unmet household demand  </li> <li>Price changes - Market adjustments</li> <li>Regional effects - Spatial distribution of impacts</li> </ul>"},{"location":"getting-started/quick-start/#visualization","title":"Visualization","text":"<p>Use the generated GeoJSON files for mapping:</p> <pre><code>import geopandas as gpd\nimport matplotlib.pyplot as plt\n\n# Load transport flows\nflows = gpd.read_file('output/Cambodia/.../transport_edges_with_flows_0.geojson')\n\n# Plot flow intensity\nflows.plot(column='flow_volume', linewidth=2, cmap='Reds')\nplt.title('Transport Flow Intensity')\nplt.show()\n</code></pre>"},{"location":"getting-started/quick-start/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/quick-start/#performance-tips","title":"Performance Tips","text":"<p>Speed up large models</p> <pre><code># Reduce firm count with cutoffs\npython disruptsc/main.py Cambodia --cutoff_firm_output_value 1000000\n\n# Filter small sectors\npython disruptsc/main.py Cambodia --cutoff_sector_output_value 50000000\n\n# Use caching for development\npython disruptsc/main.py Cambodia --cache same_transport_network_new_agents\n</code></pre>"},{"location":"getting-started/quick-start/#memory-issues","title":"Memory Issues","text":"<p>Large memory usage</p> <p>If you encounter memory issues:</p> <ul> <li>Increase system memory</li> <li>Reduce model scope/resolution</li> <li>Use firm/sector filtering</li> <li>Consider running on cloud instances</li> </ul>"},{"location":"getting-started/quick-start/#debugging","title":"Debugging","text":"<p>Troubleshooting runs</p> <pre><code># Check execution log\ntail -f output/Cambodia/.../exp.log\n\n# Validate inputs first\npython validate_inputs.py Cambodia\n\n# Run with verbose output\npython disruptsc/main.py Cambodia --verbose\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>After your first successful simulation:</p> <ol> <li>Explore parameters - Customize simulation settings</li> <li>Learn data modes - Choose MRIO vs network data</li> <li>Study output files - Detailed output analysis</li> <li>Understand architecture - Learn how the model works</li> </ol>"},{"location":"getting-started/quick-start/#example-workflow","title":"Example Workflow","text":"<p>A typical research workflow:</p> <pre><code># 1. Validate data\npython validate_inputs.py Cambodia\n\n# 2. Run baseline\npython disruptsc/main.py Cambodia\n\n# 3. Test disruption scenarios\npython disruptsc/main.py Cambodia --simulation_type disruption\n\n# 4. Analyze results\npython analysis_script.py output/Cambodia/latest/\n\n# 5. Run sensitivity analysis\nfor cutoff in 0.1 0.5 1.0; do\n    python disruptsc/main.py Cambodia --io_cutoff $cutoff\ndone\n</code></pre> <p>Congratulations! You've successfully run your first DisruptSC simulation. \ud83c\udf89</p>"},{"location":"getting-started/validation/","title":"Input Validation","text":"<p>Before running simulations, validate your input files to catch errors early and ensure data quality.</p>"},{"location":"getting-started/validation/#why-validate","title":"Why Validate?","text":"<p>Input validation helps you:</p> <ul> <li>Catch errors early before long simulation runs</li> <li>Ensure data consistency across files</li> <li>Verify file formats and required columns</li> <li>Check data quality and value ranges</li> <li>Get actionable feedback for fixing issues</li> </ul>"},{"location":"getting-started/validation/#quick-validation","title":"Quick Validation","text":"<p>Validate all input files for a scope:</p> <pre><code>python validate_inputs.py &lt;scope&gt;\n</code></pre> <p>Examples: <pre><code>python validate_inputs.py Cambodia\npython validate_inputs.py Ecuador\npython validate_inputs.py Global\n</code></pre></p>"},{"location":"getting-started/validation/#what-gets-validated","title":"What Gets Validated","text":""},{"location":"getting-started/validation/#file-existence-and-access","title":"File Existence and Access","text":"<ul> <li>All required files are present</li> <li>Files are readable</li> <li>Directory structure is correct</li> </ul>"},{"location":"getting-started/validation/#economic-data","title":"Economic Data","text":"<ul> <li>MRIO table structure and balance</li> <li>Sector table required columns and data types</li> <li>Parameter consistency between files</li> <li>Monetary units alignment</li> </ul>"},{"location":"getting-started/validation/#transport-networks","title":"Transport Networks","text":"<ul> <li>GeoJSON format validity</li> <li>LineString geometry for edges</li> <li>Coordinate systems consistency</li> <li>Network connectivity basic checks</li> </ul>"},{"location":"getting-started/validation/#spatial-data","title":"Spatial Data","text":"<ul> <li>Point geometry for locations</li> <li>Required attributes present</li> <li>Region matching with economic data</li> <li>Spatial reference consistency</li> </ul>"},{"location":"getting-started/validation/#data-ranges-and-quality","title":"Data Ranges and Quality","text":"<ul> <li>No negative values where inappropriate</li> <li>Reasonable value ranges for economic variables</li> <li>Missing data identification</li> <li>Outlier detection for key variables</li> </ul>"},{"location":"getting-started/validation/#validation-output","title":"Validation Output","text":""},{"location":"getting-started/validation/#success-message","title":"Success Message","text":"<p>When all validations pass: <pre><code>\u2705 Validation successful for Cambodia\nAll required files found and validated\nReady to run simulations\n</code></pre></p>"},{"location":"getting-started/validation/#error-messages","title":"Error Messages","text":"<p>When validation fails: <pre><code>\u274c Validation failed for Cambodia\n\nErrors found:\n- Missing file: data/Cambodia/Economic/mrio.csv\n- Invalid geometry in data/Cambodia/Transport/roads_edges.geojson\n- MRIO table is not balanced (rows != columns)\n\nWarnings:\n- Deprecated file found: data/Cambodia/legacy_data.csv\n- Large file detected: data/Cambodia/Transport/roads_edges.geojson (&gt;50MB)\n</code></pre></p>"},{"location":"getting-started/validation/#detailed-output","title":"Detailed Output","text":"<p>For verbose information: <pre><code>python validate_inputs.py Cambodia --verbose\n</code></pre></p>"},{"location":"getting-started/validation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"getting-started/validation/#file-errors","title":"File Errors","text":"Missing required files <p>Error: <code>Missing file: data/Cambodia/Economic/mrio.csv</code></p> <p>Solutions: - Check data path configuration - Verify file names match exactly - Ensure proper scope folder structure</p> <pre><code># Check data structure\nls -la data/Cambodia/Economic/\n\n# Verify data path\npython -c \"from disruptsc.paths import get_data_path; print(get_data_path('Cambodia'))\"\n</code></pre> File access permissions <p>Error: <code>Cannot read file: permission denied</code></p> <p>Solutions: <pre><code># Fix file permissions\nchmod 644 data/Cambodia/Economic/mrio.csv\n\n# Fix directory permissions\nchmod 755 data/Cambodia/\n</code></pre></p>"},{"location":"getting-started/validation/#economic-data-errors","title":"Economic Data Errors","text":"MRIO table not balanced <p>Error: <code>MRIO table is not balanced: sum(inputs) != sum(outputs)</code></p> <p>Solutions: - Check input-output table calculation - Verify monetary units consistency - Review aggregation methods - Ensure final demand is included</p> Missing required columns <p>Error: <code>Missing column 'sector' in sector_table.csv</code></p> <p>Required columns in sector_table.csv: - <code>sector</code> - Region_sector identifier - <code>type</code> - Sector type (agriculture, manufacturing, etc.) - <code>output</code> - Total yearly output - <code>final_demand</code> - Total yearly final demand - <code>usd_per_ton</code> - USD value per ton - <code>share_exporting_firms</code> - Export participation rate</p>"},{"location":"getting-started/validation/#transport-network-errors","title":"Transport Network Errors","text":"Invalid geometry <p>Error: <code>Invalid geometry in roads_edges.geojson</code></p> <p>Solutions: - Ensure LineString geometry for transport edges - Check for invalid coordinates (NaN, infinity) - Verify coordinate reference system - Use QGIS or similar tools to repair geometry</p> Network connectivity issues <p>Error: <code>Disconnected transport network components</code></p> <p>Solutions: - Check for isolated network segments - Ensure proper node connectivity - Review multimodal connections - Add connecting edges where needed</p>"},{"location":"getting-started/validation/#spatial-data-errors","title":"Spatial Data Errors","text":"Mismatched regions <p>Error: <code>Region 'REG01' in households.geojson not found in MRIO</code></p> <p>Solutions: - Check region naming consistency - Verify MRIO region definitions - Update spatial data region attributes - Check for typos in region codes</p>"},{"location":"getting-started/validation/#integration-with-model","title":"Integration with Model","text":"<p>The model automatically runs basic validation at startup:</p> <pre><code>from disruptsc.model.input_validation import validate_inputs\nfrom disruptsc.parameters import Parameters\n\n# Load parameters\nparameters = Parameters.load_parameters(paths.PARAMETER_FOLDER, scope)\n\n# Validate inputs\nis_valid, errors, warnings = validate_inputs(parameters)\n\nif not is_valid:\n    print(\"Validation errors:\", errors)\n    exit(1)\n</code></pre>"},{"location":"getting-started/validation/#advanced-validation","title":"Advanced Validation","text":""},{"location":"getting-started/validation/#custom-validation-rules","title":"Custom Validation Rules","text":"<p>For project-specific validation:</p> <pre><code>from disruptsc.model.input_validation import BaseValidator\n\nclass CustomValidator(BaseValidator):\n    def validate_custom_data(self):\n        # Your custom validation logic\n        pass\n</code></pre>"},{"location":"getting-started/validation/#batch-validation","title":"Batch Validation","text":"<p>Validate multiple scopes:</p> <pre><code>for scope in Cambodia Ecuador Global; do\n    echo \"Validating $scope...\"\n    python validate_inputs.py $scope\ndone\n</code></pre>"},{"location":"getting-started/validation/#performance-tips","title":"Performance Tips","text":"<p>For large datasets:</p> <ul> <li>Use <code>--quick</code> flag for basic validation only</li> <li>Validate subsets during development</li> <li>Cache validation results for repeated checks</li> <li>Run full validation before production runs</li> </ul>"},{"location":"getting-started/validation/#whats-next","title":"What's Next?","text":"<p>After successful validation:</p> <ol> <li>Run quick start - Test your first simulation</li> <li>Configure parameters - Customize settings</li> <li>Understand data modes - Choose appropriate mode</li> </ol>"},{"location":"research/","title":"\ud83d\udd2c Research &amp; Policy","text":""},{"location":"research/#scientific-publications","title":"\ud83d\udcc4 Scientific publications","text":"<ul> <li>Colon, C., Hallegatte, S., &amp; Rozenberg, J. (2021). Criticality analysis of a country\u2019s transport network via an agent-based supply chain model. Nature Sustainability, 4(3), 209-215.   The main paper. It is the first version of the model, which has significantly evolved since then. </li> </ul>"},{"location":"research/#policy-publications","title":"\ud83c\udfdb\ufe0f Policy publications","text":"<ul> <li> <p>Wang, B., &amp; Colon, C. (2024). Cambodia: Geospatial Analysis for Resilient Road Accessibility for Human Development and Logistic Supply. World Bank.   Application to Cambodia, as part as of a larger study on rural roads and accessibility</p> </li> <li> <p>Colon, C., Hallegatte, S., &amp; Rozenberg, J. (2019). Transportation and supply chain resilience in the United Republic of Tanzania. World Bank.   World Bank background paper to the Lifeline report. Contains a detailed description of the first version of the model.</p> </li> </ul>"},{"location":"research/#inspirations","title":"\ud83e\udde0 Inspirations","text":"<p>The model has been mostly inspired by:</p> <ul> <li>Henriet, F., Hallegatte, S., &amp; Tabourier, L. (2012). Firm-network characteristics and economic robustness to natural disasters. Journal of Economic Dynamics and Control, 36(1), 150-167.</li> </ul> <p>The open source framework has been inspired by BoARIO</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This section provides comprehensive guidance on using DisruptSC for your research and analysis needs.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>DisruptSC is designed to be flexible and configurable for different use cases. The user guide covers:</p> <ul> <li>Basic Usage - Command-line interface and simulation types</li> <li>Parameters - Configuration options and settings</li> <li>Data Modes - MRIO vs Supplier-Buyer network approaches</li> <li>Input Data - Required data files and formats</li> <li>Output Files - Understanding and interpreting results</li> </ul>"},{"location":"user-guide/#simulation-types","title":"Simulation Types","text":"<p>DisruptSC supports several simulation modes:</p> Type Purpose Use Case <code>initial_state</code> Baseline equilibrium Understand normal operations <code>disruption</code> Single disruption scenario Analyze specific events <code>disruption_mc</code> Monte Carlo analysis Statistical robustness <code>criticality</code> Infrastructure assessment Identify critical links <code>flow_calibration</code> Transport calibration Match observed data"},{"location":"user-guide/#configuration-workflow","title":"Configuration Workflow","text":"<pre><code>graph LR\n    A[Choose Scope] --&gt; B[Set Data Mode]\n    B --&gt; C[Configure Parameters]\n    C --&gt; D[Validate Inputs]\n    D --&gt; E[Run Simulation]\n    E --&gt; F[Analyze Results]</code></pre>"},{"location":"user-guide/#key-concepts","title":"Key Concepts","text":"Scope The geographic region of analysis (e.g., Cambodia, Ecuador, Global) Regions Sub-national administrative units within the scope Sectors Economic activity categories based on ISIC/NAICS classifications Agents Economic actors: firms (producers), households (consumers), countries (trade partners)"},{"location":"user-guide/#best-practices","title":"Best Practices","text":"<p>Performance Optimization</p> <ul> <li>Use caching for repeated runs with <code>--cache</code> options</li> <li>Filter small firms/sectors to reduce computational load</li> <li>Consider parallel execution for large-scale analysis</li> </ul> <p>Data Quality</p> <ul> <li>Always validate inputs before running simulations</li> <li>Check MRIO table balance and consistency</li> <li>Verify transport network connectivity</li> </ul> <p>Reproducibility</p> <ul> <li>Save parameter files with your results</li> <li>Document any data preprocessing steps</li> <li>Use version control for configuration changes</li> </ul>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the command-line interface and basic usage patterns for DisruptSC.</p>"},{"location":"user-guide/basic-usage/#command-line-interface","title":"Command Line Interface","text":"<p>The main entry point for DisruptSC is <code>disruptsc/main.py</code>:</p> <pre><code>python disruptsc/main.py &lt;scope&gt; [options]\n</code></pre>"},{"location":"user-guide/basic-usage/#basic-syntax","title":"Basic Syntax","text":"<pre><code># Basic usage\npython disruptsc/main.py &lt;region&gt;\n\n# With caching options  \npython disruptsc/main.py &lt;region&gt; --cache &lt;cache_type&gt;\n\n# With custom parameters\npython disruptsc/main.py &lt;region&gt; --duration 90 --io_cutoff 0.5\n\n# With cache isolation (for concurrent server runs)\npython disruptsc/main.py &lt;region&gt; --cache_isolation\n</code></pre>"},{"location":"user-guide/basic-usage/#scope-argument","title":"Scope Argument","text":"<p>The <code>scope</code> argument specifies the region/case study:</p> <ul> <li>Must match a data folder: <code>data/&lt;scope&gt;/</code> or <code>input/&lt;scope&gt;/</code></li> <li>Must have corresponding parameter file: <code>parameter/user_defined_&lt;scope&gt;.yaml</code></li> </ul> <p>Available scopes: - <code>Cambodia</code> - Southeast Asian economy - <code>ECA</code> - Europe &amp; Central Asia - <code>Ecuador</code> - South American economy - <code>Global</code> - World economy - <code>Testkistan</code> - Synthetic test case</p>"},{"location":"user-guide/basic-usage/#command-options","title":"Command Options","text":""},{"location":"user-guide/basic-usage/#caching-options","title":"Caching Options","text":"Option Description Use Case <code>same_transport_network_new_agents</code> Reuse transport network, rebuild agents Testing agent parameters <code>same_agents_new_sc_network</code> Reuse agents, rebuild supply chain Testing supplier selection <code>same_sc_network_new_logistic_routes</code> Reuse supply chain, rebuild logistics Testing transport parameters <code>same_logistic_routes</code> Reuse everything Running different disruption scenarios"},{"location":"user-guide/basic-usage/#parameter-overrides","title":"Parameter Overrides","text":"<pre><code># Economic parameters\n--io_cutoff 0.5                    # Input-output cutoff threshold\n--cutoff_firm_output_value 1000000 # Minimum firm output (in model units)\n--duration 90                      # Simulation duration (time steps)\n\n# Transport parameters  \n--capacity_constraint true          # Enable transport capacity limits\n--transport_to_households false     # Disable household transport modeling\n\n# Performance parameters\n--sectors_to_include \"AGR,MAN\"      # Only include specified sectors\n--sectors_to_exclude \"SER\"          # Exclude specified sectors\n</code></pre>"},{"location":"user-guide/basic-usage/#utility-options","title":"Utility Options","text":"<pre><code>--version                          # Show version information\n--help                            # Show help message\n--verbose                         # Enable verbose output\n--config path/to/config.yaml      # Use custom config file\n--cache_isolation                 # Isolate cache directory per process (for server runs)\n</code></pre>"},{"location":"user-guide/basic-usage/#simulation-workflow","title":"Simulation Workflow","text":""},{"location":"user-guide/basic-usage/#standard-workflow","title":"Standard Workflow","text":"<pre><code>graph TD\n    A[1. Setup Transport Network] --&gt; B[2. Setup Agents]\n    B --&gt; C[3. Setup Supply Chain Network]\n    C --&gt; D[4. Setup Logistic Routes]\n    D --&gt; E[5. Initialize Economic Variables]\n    E --&gt; F[6. Run Time Step 0]\n    F --&gt; G[7. Run Disruption Scenario]</code></pre>"},{"location":"user-guide/basic-usage/#effect-of-caching","title":"Effect of Caching","text":"<p>The <code>--cache</code> option determines where the workflow starts:</p> <ul> <li>No cache: Starts at step 1 (full rebuild)</li> <li><code>same_transport_network_new_agents</code>: Starts at step 2</li> <li><code>same_agents_new_sc_network</code>: Starts at step 3  </li> <li><code>same_sc_network_new_logistic_routes</code>: Starts at step 4</li> <li><code>same_logistic_routes</code>: Starts at step 5</li> </ul> <p>Development Workflow</p> <p>Use caching to speed up development:</p> <pre><code># Initial run (slow)\npython disruptsc/main.py Cambodia\n\n# Test different agent parameters (faster)\npython disruptsc/main.py Cambodia --cache same_transport_network_new_agents\n\n# Test different disruption scenarios (fastest)\npython disruptsc/main.py Cambodia --cache same_logistic_routes\n</code></pre>"},{"location":"user-guide/basic-usage/#configuration-files","title":"Configuration Files","text":""},{"location":"user-guide/basic-usage/#parameter-structure","title":"Parameter Structure","text":"<p>DisruptSC uses a hierarchical configuration system:</p> <ol> <li><code>parameter/default.yaml</code> - Base parameters (don't edit)</li> <li><code>parameter/user_defined_&lt;scope&gt;.yaml</code> - Scope-specific overrides</li> </ol>"},{"location":"user-guide/basic-usage/#key-configuration-sections","title":"Key Configuration Sections","text":""},{"location":"user-guide/basic-usage/#simulation-settings","title":"Simulation Settings","text":"<pre><code>simulation_type: \"initial_state\"  # or \"disruption\", \"criticality\", etc.\nt_final: 365                      # Simulation duration (days)\ntime_resolution: \"day\"            # Time unit\n</code></pre>"},{"location":"user-guide/basic-usage/#data-sources","title":"Data Sources","text":"<pre><code>firm_data_type: \"mrio\"            # \"mrio\" or \"supplier-buyer network\"\nmonetary_units_in_model: \"mUSD\"   # Model currency unit\nmonetary_units_in_data: \"USD\"     # Data currency unit\n</code></pre>"},{"location":"user-guide/basic-usage/#economic-parameters","title":"Economic Parameters","text":"<pre><code>io_cutoff: 0.01                   # Input-output coefficient threshold\ncutoff_firm_output:\n  value: 1000000\n  unit: \"USD\"\ncutoff_sector_output:\n  value: 50000000  \n  unit: \"USD\"\n</code></pre>"},{"location":"user-guide/basic-usage/#transport-settings","title":"Transport Settings","text":"<pre><code>with_transport: true              # Enable transport modeling\ncapacity_constraint: false       # Enable capacity constraints\ntransport_to_households: false   # Model household transport\n</code></pre>"},{"location":"user-guide/basic-usage/#file-paths","title":"File Paths","text":"<pre><code>filepaths:\n  mrio: \"Economic/mrio.csv\"\n  sector_table: \"Economic/sector_table.csv\"\n  households_spatial: \"Spatial/households.geojson\"\n  # ... other file paths\n</code></pre>"},{"location":"user-guide/basic-usage/#simulation-types","title":"Simulation Types","text":""},{"location":"user-guide/basic-usage/#initial-state-analysis","title":"Initial State Analysis","text":"<p>Analyze baseline equilibrium without disruptions:</p> <pre><code>simulation_type: \"initial_state\"\n</code></pre> <p>Purpose: Understand normal economic operations Output: Equilibrium flows, agent states, network utilization</p>"},{"location":"user-guide/basic-usage/#disruption-simulation","title":"Disruption Simulation","text":"<p>Single disruption scenario:</p> <pre><code>simulation_type: \"disruption\"\nevents:\n  - type: \"transport_disruption\"\n    # ... disruption configuration\n</code></pre> <p>Purpose: Analyze specific disruption impacts Output: Time series of economic impacts, recovery dynamics</p>"},{"location":"user-guide/basic-usage/#monte-carlo-analysis","title":"Monte Carlo Analysis","text":"<p>Multiple disruption realizations controlled by the <code>mc_repetitions</code> parameter:</p> <pre><code># Monte Carlo configuration in YAML\nmc_repetitions: 100               # Run 100 iterations\nsimulation_type: \"disruption\"     # Base simulation type to repeat\nevents:\n  - type: \"transport_disruption\"\n    # ... disruption configuration\n</code></pre> <p>Monte Carlo Behavior: - <code>mc_repetitions = 0, False, or None</code>: Single run with full output folder - <code>mc_repetitions &gt;= 1</code>: Multiple runs with consolidated CSV results only</p> <p>Purpose: Statistical analysis of disruption impacts Output: Single CSV file with aggregated results across all iterations</p>"},{"location":"user-guide/basic-usage/#criticality-assessment","title":"Criticality Assessment","text":"<p>Systematic infrastructure assessment:</p> <pre><code>simulation_type: \"criticality\"\ncriticality:\n  duration: 30\n  # ... criticality configuration\n</code></pre> <p>Purpose: Identify critical infrastructure links Output: Criticality rankings, vulnerability maps</p>"},{"location":"user-guide/basic-usage/#flow-calibration","title":"Flow Calibration","text":"<p>Calibrate transport flows to observed data:</p> <pre><code>simulation_type: \"flow_calibration\"\n# ... calibration configuration\n</code></pre> <p>Purpose: Match model outputs to empirical data Output: Calibrated parameters, goodness-of-fit metrics</p>"},{"location":"user-guide/basic-usage/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<p>Systematic parameter exploration across multiple parameter combinations:</p> <pre><code>simulation_type: \"disruption-sensitivity\"\nsensitivity:\n  io_cutoff: [0.01, 0.1]\n  utilization: [0.8, 1.0]\n  inventory_duration_targets.values.transport: [1, 3, 5]\n</code></pre> <p>Purpose: Understand model sensitivity to parameter variations Output: CSV file with results for all parameter combinations</p> <p>Configuration: - Parameter ranges: List values for each parameter to vary - Nested parameters: Use dot notation for complex parameters - Cartesian product: All combinations automatically generated - No caching: Each combination rebuilds complete model</p> <p>Example - 12 combinations (2\u00d72\u00d73): <pre><code>python disruptsc/main.py Ecuador --simulation_type disruption-sensitivity\n</code></pre></p> <p>Output: <code>sensitivity_TIMESTAMP.csv</code> with columns for each parameter plus final household/country losses</p>"},{"location":"user-guide/basic-usage/#ad-hoc-analysis","title":"Ad Hoc Analysis","text":"<p>Systematic testing of sector or geographic vulnerability:</p>"},{"location":"user-guide/basic-usage/#sector-analysis","title":"Sector Analysis","text":"<pre><code>simulation_type: \"ad_hoc_sectors\"\n</code></pre> <p>Purpose: Test disruption impact on each sector individually Output: Comparative sector vulnerability assessment</p>"},{"location":"user-guide/basic-usage/#geographic-analysis","title":"Geographic Analysis","text":"<pre><code>simulation_type: \"ad_hoc_provinces\"  # or \"ad_hoc_cantons\"\n</code></pre> <p>Purpose: Test disruption impact on each geographic region individually Output: Spatial vulnerability mapping</p>"},{"location":"user-guide/basic-usage/#combined-analysis","title":"Combined Analysis","text":"<pre><code>simulation_type: \"ad_hoc_province_sectors\"  # or \"ad_hoc_canton_sectors\"\n</code></pre> <p>Purpose: Test disruption impact on all (region, sector) combinations Output: Detailed spatial-sectoral vulnerability matrix</p>"},{"location":"user-guide/basic-usage/#stationary-test","title":"Stationary Test","text":"<p>Model stability and equilibrium validation:</p> <pre><code>simulation_type: \"stationary_test\"\n</code></pre> <p>Purpose: Verify model reaches stable equilibrium without disruptions Output: Equilibrium validation metrics and convergence analysis</p>"},{"location":"user-guide/basic-usage/#data-modes","title":"Data Modes","text":"<p>DisruptSC supports two data input modes:</p>"},{"location":"user-guide/basic-usage/#mrio-mode-default","title":"MRIO Mode (Default)","text":"<pre><code>firm_data_type: \"mrio\"  # or omit parameter\n</code></pre> <p>Data Requirements: - Multi-Regional Input-Output table (<code>Economic/mrio.csv</code>) - Sector definitions (<code>Economic/sector_table.csv</code>) - Spatial disaggregation files (<code>Spatial/*.geojson</code>)</p> <p>Generated: - Firms from MRIO output data - Households from MRIO final demand - Countries from MRIO trade flows - Supply chains from technical coefficients</p>"},{"location":"user-guide/basic-usage/#supplier-buyer-network-mode","title":"Supplier-Buyer Network Mode","text":"<pre><code>firm_data_type: \"supplier-buyer network\"\n</code></pre> <p>Additional Requirements: - Firm data (<code>Economic/firm_table.csv</code>) - Location data (<code>Economic/location_table.csv</code>) - Transaction data (<code>Economic/transaction_table.csv</code>)</p> <p>Use Case: When you have detailed firm-level transaction data</p> <p>Mode Selection</p> <p>Use MRIO mode when: - You have standard economic accounts data - Working at regional/national scale - Need comprehensive coverage</p> <p>Use supplier-buyer mode when: - You have detailed firm transaction data - Studying specific supply chains - Need micro-level accuracy</p>"},{"location":"user-guide/basic-usage/#output-management","title":"Output Management","text":""},{"location":"user-guide/basic-usage/#output-structure","title":"Output Structure","text":"<p>Results are saved to timestamped folders:</p> <pre><code>output/&lt;scope&gt;/&lt;timestamp&gt;/\n\u251c\u2500\u2500 firm_data.json           # Firm state time series\n\u251c\u2500\u2500 household_data.json      # Household data\n\u251c\u2500\u2500 country_data.json        # Country trade data\n\u251c\u2500\u2500 firm_table.geojson       # Firm locations and attributes\n\u251c\u2500\u2500 household_table.geojson  # Household locations\n\u251c\u2500\u2500 transport_edges_with_flows_0.geojson  # Transport flows\n\u251c\u2500\u2500 sc_network_edgelist.csv  # Supply chain network\n\u251c\u2500\u2500 parameters.yaml          # Run configuration\n\u2514\u2500\u2500 exp.log                  # Execution log\n</code></pre>"},{"location":"user-guide/basic-usage/#key-output-files","title":"Key Output Files","text":""},{"location":"user-guide/basic-usage/#time-series-data","title":"Time Series Data","text":"<ul> <li><code>*_data.json</code> - Agent state evolution over time</li> <li><code>flow_df_*.csv</code> - Transport flow data by time step</li> <li><code>loss_*.csv</code> - Economic loss metrics</li> </ul>"},{"location":"user-guide/basic-usage/#spatial-data","title":"Spatial Data","text":"<ul> <li><code>*_table.geojson</code> - Agent locations with attributes</li> <li><code>transport_edges_with_flows_*.geojson</code> - Network flows for visualization</li> </ul>"},{"location":"user-guide/basic-usage/#network-data","title":"Network Data","text":"<ul> <li><code>sc_network_edgelist.csv</code> - Supply chain relationships</li> <li><code>io_table.csv</code> - Input-output flows</li> </ul>"},{"location":"user-guide/basic-usage/#metadata","title":"Metadata","text":"<ul> <li><code>parameters.yaml</code> - Complete configuration snapshot</li> <li><code>exp.log</code> - Detailed execution log with timing and debug info</li> </ul>"},{"location":"user-guide/basic-usage/#result-analysis","title":"Result Analysis","text":"<p>Basic result exploration:</p> <pre><code>import json\nimport pandas as pd\nimport geopandas as gpd\n\n# Load time series data\nwith open('firm_data.json', 'r') as f:\n    firm_data = json.load(f)\n\n# Load spatial results\nfirms = gpd.read_file('firm_table.geojson')\nflows = gpd.read_file('transport_edges_with_flows_0.geojson')\n\n# Analyze production losses\nproduction_loss = pd.DataFrame(firm_data['production']).diff(axis=1)\ntotal_loss = production_loss.sum().sum()\nprint(f\"Total production loss: {total_loss:.2f}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/basic-usage/#development-workflow","title":"Development Workflow","text":"<ol> <li>Start small - Test with <code>Testkistan</code> first</li> <li>Use caching - Speed up iterative development</li> <li>Validate inputs - Always run validation before long simulations</li> <li>Monitor logs - Check <code>exp.log</code> for issues</li> <li>Save configurations - Version control your parameter files</li> </ol>"},{"location":"user-guide/basic-usage/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Use firm filtering for large models\npython disruptsc/main.py Cambodia --cutoff_firm_output_value 5000000\n\n# Exclude service sectors if not needed\npython disruptsc/main.py Cambodia --sectors_to_exclude \"SER,TRA\"\n\n# Disable household transport for faster runs\npython disruptsc/main.py Cambodia --transport_to_households false\n</code></pre>"},{"location":"user-guide/basic-usage/#production-runs","title":"Production Runs","text":"<pre><code># Full validation before production\npython validate_inputs.py Cambodia\n\n# Production run with full logging\npython disruptsc/main.py Cambodia --verbose &gt; production.log 2&gt;&amp;1\n\n# Archive results with metadata\ncp -r output/Cambodia/latest/ results/cambodia_baseline_$(date +%Y%m%d)\n</code></pre>"},{"location":"user-guide/basic-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/basic-usage/#common-issues","title":"Common Issues","text":"<p>Memory errors</p> <p>Solution: Reduce model size or increase system memory <pre><code>python disruptsc/main.py Cambodia --cutoff_firm_output_value 10000000\n</code></pre></p> <p>Long initialization times</p> <p>Solution: Use caching for repeated runs <pre><code>python disruptsc/main.py Cambodia --cache same_transport_network_new_agents\n</code></pre></p> <p>Missing data files</p> <p>Solution: Check data path and file structure <pre><code>python validate_inputs.py Cambodia\nls -la data/Cambodia/Economic/\n</code></pre></p>"},{"location":"user-guide/basic-usage/#debug-mode","title":"Debug Mode","text":"<p>For detailed debugging:</p> <pre><code># Enable verbose logging\npython disruptsc/main.py Cambodia --verbose\n\n# Check execution log\ntail -f output/Cambodia/latest/exp.log\n\n# Validate data first\npython validate_inputs.py Cambodia --verbose\n</code></pre>"},{"location":"user-guide/data-modes/","title":"Data Modes","text":"<p>DisruptSC supports two data input modes for creating economic agents and supply chains. This guide explains when and how to use each mode.</p>"},{"location":"user-guide/data-modes/#overview","title":"Overview","text":"Mode Data Source Use Case Complexity MRIO Input-Output tables Regional/national studies Simple Supplier-Buyer Network Transaction data Supply chain studies Advanced"},{"location":"user-guide/data-modes/#mrio-mode-default","title":"MRIO Mode (Default)","text":"<p>Multi-Regional Input-Output (MRIO) mode uses standard economic accounts data to generate agents and supply chains.</p>"},{"location":"user-guide/data-modes/#configuration","title":"Configuration","text":"<pre><code># Default - can be omitted\nfirm_data_type: \"mrio\"\n</code></pre>"},{"location":"user-guide/data-modes/#data-requirements","title":"Data Requirements","text":""},{"location":"user-guide/data-modes/#required-files","title":"Required Files","text":"<pre><code>data/&lt;scope&gt;/\n\u251c\u2500\u2500 Economic/\n\u2502   \u251c\u2500\u2500 mrio.csv            # Multi-regional input-output table\n\u2502   \u2514\u2500\u2500 sector_table.csv    # Sector definitions and parameters\n\u2514\u2500\u2500 Spatial/\n    \u251c\u2500\u2500 households.geojson  # Household spatial distribution\n    \u251c\u2500\u2500 countries.geojson   # Country/import entry points\n    \u2514\u2500\u2500 firms.geojson       # Firm spatial disaggregation\n</code></pre>"},{"location":"user-guide/data-modes/#mrio-table-structure","title":"MRIO Table Structure","text":"<p>The <code>mrio.csv</code> file contains input-output flows:</p> <pre><code>region_sector,AGR_Region1,MAN_Region1,SER_Region1,HH_Region1,Export_CHN,...\nAGR_Region1,150.5,75.2,25.0,500.0,100.0,...\nMAN_Region1,50.0,200.0,150.0,800.0,150.0,...\nSER_Region1,25.0,100.0,300.0,600.0,50.0,...\nImport_CHN,10.0,50.0,20.0,100.0,0.0,...\n...\n</code></pre> <p>Key features: - Rows = selling sectors, Columns = buying sectors - Final demand columns (households, exports) - Import rows for international trade - Monetary values in consistent units</p>"},{"location":"user-guide/data-modes/#sector-table-structure","title":"Sector Table Structure","text":"<p>The <code>sector_table.csv</code> defines sector characteristics:</p> <pre><code>sector,type,output,final_demand,usd_per_ton,share_exporting_firms,supply_data,cutoff\nAGR_Region1,agriculture,2000000,500000,950,0.16,ag_prod,3500000\nMAN_Region1,manufacturing,5000000,800000,2864,0.45,man_prod,5000000\nSER_Region1,service,3000000,600000,0,0.10,ser_emp,2000000\n</code></pre> <p>Required columns: - <code>sector</code> - Region_sector identifier - <code>type</code> - Sector category (agriculture, manufacturing, etc.) - <code>output</code> - Total yearly output (model currency) - <code>final_demand</code> - Total yearly final demand - <code>usd_per_ton</code> - USD value per ton (0 for services) - <code>share_exporting_firms</code> - Fraction of firms that export - <code>supply_data</code> - Spatial disaggregation attribute - <code>cutoff</code> - Minimum threshold for firm creation</p>"},{"location":"user-guide/data-modes/#how-mrio-mode-works","title":"How MRIO Mode Works","text":"<pre><code>graph TD\n    A[MRIO Table] --&gt; B[Extract Output Data]\n    A --&gt; C[Extract Technical Coefficients]\n    A --&gt; D[Extract Final Demand]\n\n    B --&gt; E[Create Firms]\n    C --&gt; F[Define Supply Chains]\n    D --&gt; G[Create Households]\n    A --&gt; H[Create Countries]\n\n    I[Spatial Data] --&gt; E\n    I --&gt; G\n    I --&gt; H</code></pre>"},{"location":"user-guide/data-modes/#1-firm-creation","title":"1. Firm Creation","text":"<ul> <li>One firm per region-sector with non-zero output</li> <li>Spatial disaggregation based on <code>firms.geojson</code> attributes</li> <li>Production capacity from MRIO output data</li> <li>Input requirements from technical coefficients</li> </ul>"},{"location":"user-guide/data-modes/#2-household-creation","title":"2. Household Creation","text":"<ul> <li>Spatial distribution from <code>households.geojson</code></li> <li>Consumption patterns from MRIO final demand</li> <li>Population weighting for disaggregation</li> </ul>"},{"location":"user-guide/data-modes/#3-country-creation","title":"3. Country Creation","text":"<ul> <li>Trade partners from MRIO import/export data  </li> <li>Entry points from <code>countries.geojson</code></li> <li>Trade volumes from international flows</li> </ul>"},{"location":"user-guide/data-modes/#4-supply-chain-formation","title":"4. Supply Chain Formation","text":"<ul> <li>Technical coefficients define input requirements</li> <li>Supplier selection based on spatial proximity and importance</li> <li>Import/export links for international trade</li> </ul>"},{"location":"user-guide/data-modes/#advantages","title":"Advantages","text":"<p>\u2705 Comprehensive coverage - All economic sectors included \u2705 Data availability - Standard economic accounts exist globally \u2705 Consistent framework - Based on economic theory \u2705 Regional detail - Sub-national disaggregation possible \u2705 Simple setup - Minimal data requirements</p>"},{"location":"user-guide/data-modes/#limitations","title":"Limitations","text":"<p>\u274c Aggregated view - Less firm-level detail \u274c Synthetic supply chains - Generated, not observed \u274c Homogeneous firms - Single firm per region-sector \u274c Static relationships - No firm dynamics</p>"},{"location":"user-guide/data-modes/#best-use-cases","title":"Best Use Cases","text":"<ul> <li>Regional impact analysis - Natural disasters, trade shocks</li> <li>Policy evaluation - Infrastructure investments, regulations</li> <li>Academic research - Theoretical model applications</li> <li>Baseline studies - Understanding economic structure</li> </ul>"},{"location":"user-guide/data-modes/#supplier-buyer-network-mode","title":"Supplier-Buyer Network Mode","text":"<p>This mode uses detailed firm-level transaction data to create explicit supply chain networks.</p>"},{"location":"user-guide/data-modes/#configuration_1","title":"Configuration","text":"<pre><code>firm_data_type: \"supplier-buyer network\"\n</code></pre>"},{"location":"user-guide/data-modes/#additional-data-requirements","title":"Additional Data Requirements","text":"<pre><code>data/&lt;scope&gt;/\n\u251c\u2500\u2500 Economic/\n\u2502   \u251c\u2500\u2500 mrio.csv            # Still required for households/countries\n\u2502   \u251c\u2500\u2500 sector_table.csv    # Still required for sectors\n\u2502   \u251c\u2500\u2500 firm_table.csv      # Firm-level data\n\u2502   \u251c\u2500\u2500 location_table.csv  # Firm locations\n\u2502   \u2514\u2500\u2500 transaction_table.csv  # Supplier-buyer transactions\n\u2514\u2500\u2500 Spatial/\n    \u251c\u2500\u2500 households.geojson  # Still required\n    \u2514\u2500\u2500 countries.geojson   # Still required\n</code></pre>"},{"location":"user-guide/data-modes/#firm-table-structure","title":"Firm Table Structure","text":"<pre><code>id,sector,region,output,employees,importance\n1001,AGR_Region1,Region1,500000,50,0.15\n1002,AGR_Region1,Region1,750000,75,0.25\n1003,MAN_Region1,Region1,2000000,200,0.45\n</code></pre>"},{"location":"user-guide/data-modes/#location-table-structure","title":"Location Table Structure","text":"<pre><code>firm_id,long,lat,transport_node,admin_level1\n1001,-104.532,40.123,node_456,State1\n1002,-104.445,40.234,node_789,State1\n1003,-104.612,40.087,node_234,State2\n</code></pre>"},{"location":"user-guide/data-modes/#transaction-table-structure","title":"Transaction Table Structure","text":"<pre><code>supplier_id,buyer_id,product_sector,transaction,is_essential\n1001,1003,AGR_Region1,150000,true\n1002,1003,AGR_Region1,200000,false\n1004,1003,MAN_Region2,500000,true\n</code></pre>"},{"location":"user-guide/data-modes/#how-network-mode-works","title":"How Network Mode Works","text":"<pre><code>graph TD\n    A[Firm Table] --&gt; B[Create Individual Firms]\n    C[Location Table] --&gt; B\n    D[Transaction Table] --&gt; E[Define Explicit Links]\n    F[MRIO Table] --&gt; G[Create Households/Countries]\n\n    B --&gt; H[Firm Agents]\n    E --&gt; I[Supply Chain Network]\n    G --&gt; J[Household/Country Agents]</code></pre>"},{"location":"user-guide/data-modes/#1-firm-creation_1","title":"1. Firm Creation","text":"<ul> <li>Individual firms from firm table records</li> <li>Heterogeneous characteristics - size, productivity, location</li> <li>Spatial placement from location table</li> <li>Realistic firm distribution</li> </ul>"},{"location":"user-guide/data-modes/#2-supply-chain-creation","title":"2. Supply Chain Creation","text":"<ul> <li>Explicit transactions from transaction table</li> <li>Observed relationships - actual supplier-buyer pairs</li> <li>Transaction volumes - real economic flows</li> <li>Essential vs. substitutable suppliers</li> </ul>"},{"location":"user-guide/data-modes/#3-householdcountry-creation","title":"3. Household/Country Creation","text":"<ul> <li>Still uses MRIO for households and countries</li> <li>Ensures completeness of economic system</li> <li>Maintains consistency with national accounts</li> </ul>"},{"location":"user-guide/data-modes/#advantages_1","title":"Advantages","text":"<p>\u2705 Firm-level detail - Individual heterogeneous firms \u2705 Observed relationships - Real supplier-buyer networks \u2705 Realistic behavior - Based on actual transactions \u2705 Supply chain accuracy - Explicit network structure \u2705 Firm dynamics - Can model firm entry/exit</p>"},{"location":"user-guide/data-modes/#limitations_1","title":"Limitations","text":"<p>\u274c Data intensive - Requires detailed firm databases \u274c Limited availability - Few countries have this data \u274c Confidentiality - Firm data often sensitive \u274c Complexity - More difficult to set up and validate \u274c Partial coverage - May miss informal sectors</p>"},{"location":"user-guide/data-modes/#best-use-cases_1","title":"Best Use Cases","text":"<ul> <li>Supply chain resilience - Critical supplier identification</li> <li>Firm-level analysis - Individual company impacts  </li> <li>Network studies - Supply chain structure analysis</li> <li>Policy targeting - Firm-specific interventions</li> </ul>"},{"location":"user-guide/data-modes/#mode-comparison","title":"Mode Comparison","text":""},{"location":"user-guide/data-modes/#data-requirements_1","title":"Data Requirements","text":"Aspect MRIO Mode Network Mode Setup complexity Simple Complex Data availability High Low Data sensitivity Low High Preprocessing Minimal Extensive"},{"location":"user-guide/data-modes/#model-characteristics","title":"Model Characteristics","text":"Aspect MRIO Mode Network Mode Firm representation Aggregate Individual Supply chains Generated Observed Heterogeneity Low High Validation Economic accounts Firm surveys"},{"location":"user-guide/data-modes/#computational-performance","title":"Computational Performance","text":"Aspect MRIO Mode Network Mode Model size Smaller Larger Memory usage Lower Higher Runtime Faster Slower Scalability Better Limited"},{"location":"user-guide/data-modes/#choosing-the-right-mode","title":"Choosing the Right Mode","text":""},{"location":"user-guide/data-modes/#decision-framework","title":"Decision Framework","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Do you have firm-level transaction data?}\n    B --&gt;|No| C[Use MRIO Mode]\n    B --&gt;|Yes| D{Is data quality high?}\n    D --&gt;|No| C\n    D --&gt;|Yes| E{Is coverage complete?}\n    E --&gt;|No| F{Can you supplement missing data?}\n    F --&gt;|No| C\n    F --&gt;|Yes| G[Use Network Mode]\n    E --&gt;|Yes| G</code></pre>"},{"location":"user-guide/data-modes/#use-mrio-mode-when","title":"Use MRIO Mode When:","text":"<ul> <li>Standard analysis - Regional impact assessment</li> <li>Data constraints - Limited access to firm data</li> <li>Academic research - Theoretical model applications</li> <li>Policy analysis - Broad economic impacts</li> <li>Initial exploration - Understanding system structure</li> </ul>"},{"location":"user-guide/data-modes/#use-network-mode-when","title":"Use Network Mode When:","text":"<ul> <li>Supply chain focus - Detailed network analysis</li> <li>Firm-level questions - Individual company impacts</li> <li>Available data - Access to transaction databases</li> <li>Validation needs - Match observed supply chains</li> <li>Advanced analysis - Network topology studies</li> </ul>"},{"location":"user-guide/data-modes/#migration-between-modes","title":"Migration Between Modes","text":""},{"location":"user-guide/data-modes/#from-mrio-to-network","title":"From MRIO to Network","text":"<p>If you start with MRIO and later obtain firm data:</p> <ol> <li>Keep MRIO files - Still needed for households/countries</li> <li>Add firm tables - Supplement with detailed data</li> <li>Update configuration - Change <code>firm_data_type</code></li> <li>Validate consistency - Check aggregate matches</li> </ol>"},{"location":"user-guide/data-modes/#from-network-to-mrio","title":"From Network to MRIO","text":"<p>If network data becomes unavailable:</p> <ol> <li>Aggregate firm data - Create MRIO equivalent</li> <li>Remove firm tables - Keep only aggregated data</li> <li>Update configuration - Revert to MRIO mode</li> <li>Verify results - Compare with network version</li> </ol>"},{"location":"user-guide/data-modes/#validation-and-quality-checks","title":"Validation and Quality Checks","text":""},{"location":"user-guide/data-modes/#mrio-mode-validation","title":"MRIO Mode Validation","text":"<pre><code># Check MRIO balance\npython validate_inputs.py Cambodia --check-mrio-balance\n\n# Verify sector consistency  \npython validate_inputs.py Cambodia --check-sectors\n\n# Spatial consistency\npython validate_inputs.py Cambodia --check-spatial\n</code></pre>"},{"location":"user-guide/data-modes/#network-mode-validation","title":"Network Mode Validation","text":"<pre><code># Firm data consistency\npython validate_inputs.py Cambodia --check-firms\n\n# Transaction completeness\npython validate_inputs.py Cambodia --check-transactions\n\n# Network connectivity\npython validate_inputs.py Cambodia --check-network\n</code></pre>"},{"location":"user-guide/data-modes/#cross-mode-comparison","title":"Cross-Mode Comparison","text":"<pre><code># Compare aggregate results\nfrom disruptsc.validation import compare_modes\n\nresults = compare_modes(\n    mrio_results='output/Cambodia_mrio/',\n    network_results='output/Cambodia_network/'\n)\nprint(results.summary())\n</code></pre>"},{"location":"user-guide/data-modes/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/data-modes/#data-preparation","title":"Data Preparation","text":"<ol> <li>Start with validation - Always validate before simulation</li> <li>Check aggregation - Ensure consistency between levels</li> <li>Document sources - Track data provenance</li> <li>Version control - Manage data updates</li> </ol>"},{"location":"user-guide/data-modes/#model-development","title":"Model Development","text":"<ol> <li>Begin with MRIO - Start simple, add complexity</li> <li>Validate incrementally - Test each data addition</li> <li>Compare modes - Cross-validate when possible</li> <li>Document assumptions - Record modeling choices</li> </ol>"},{"location":"user-guide/data-modes/#production-use","title":"Production Use","text":"<ol> <li>Choose appropriate mode - Match to research question</li> <li>Validate results - Check against known benchmarks</li> <li>Sensitivity analysis - Test parameter variations</li> <li>Archive configurations - Preserve reproducibility</li> </ol>"},{"location":"user-guide/input-data/","title":"Input Data","text":"<p>This comprehensive guide explains all input data files required by DisruptSC, their formats, and how to prepare them.</p>"},{"location":"user-guide/input-data/#data-organization","title":"Data Organization","text":"<p>All input data must be organized by scope (region/country):</p> <pre><code>data/&lt;scope&gt;/               # e.g., data/Cambodia/\n\u251c\u2500\u2500 Economic/               # Economic and sector data\n\u251c\u2500\u2500 Transport/              # Infrastructure networks  \n\u251c\u2500\u2500 Spatial/                # Geographic disaggregation\n\u2514\u2500\u2500 Disruption/            # Disruption scenarios (optional)\n</code></pre>"},{"location":"user-guide/input-data/#economic-data","title":"Economic Data","text":""},{"location":"user-guide/input-data/#mrio-table-economicmriocsv","title":"MRIO Table (<code>Economic/mrio.csv</code>)","text":"<p>The Multi-Regional Input-Output table is the core economic data file.</p>"},{"location":"user-guide/input-data/#structure","title":"Structure","text":"<pre><code>region_sector,AGR_REG1,MAN_REG1,SER_REG1,HH_REG1,Export_CHN,Import_CHN\nAGR_REG1,150.5,75.2,25.0,500.0,100.0,0.0\nMAN_REG1,50.0,200.0,150.0,800.0,150.0,0.0\nSER_REG1,25.0,100.0,300.0,600.0,50.0,0.0\nImport_CHN,10.0,50.0,20.0,100.0,0.0,0.0\n</code></pre>"},{"location":"user-guide/input-data/#required-features","title":"Required Features","text":"<ul> <li>Square matrix - Same sectors in rows and columns</li> <li>Monetary units - Consistent currency (USD, kUSD, mUSD)</li> <li>Balanced flows - Row sums \u2248 column sums for each sector</li> <li>Final demand - Household columns (HH_RegionName)</li> <li>Trade flows - Export/Import columns for international trade</li> </ul>"},{"location":"user-guide/input-data/#region-sector-naming","title":"Region-Sector Naming","text":"<p>Use format: <code>{SectorCode}_{RegionCode}</code></p> <p>Examples: - <code>AGR_KHM</code> - Agriculture in Cambodia - <code>MAN_THA</code> - Manufacturing in Thailand - <code>SER_VNM</code> - Services in Vietnam</p>"},{"location":"user-guide/input-data/#special-columnsrows","title":"Special Columns/Rows","text":"Type Format Purpose Households <code>HH_{Region}</code> Final consumption demand Exports <code>Export_{Country}</code> International exports Imports <code>Import_{Country}</code> International imports"},{"location":"user-guide/input-data/#data-quality-requirements","title":"Data Quality Requirements","text":"<pre><code># Validation checks performed\nimport pandas as pd\n\nmrio = pd.read_csv('mrio.csv', index_col=0)\n\n# 1. Square matrix\nassert mrio.shape[0] == mrio.shape[1], \"MRIO must be square\"\n\n# 2. Non-negative values\nassert (mrio &gt;= 0).all().all(), \"Negative values not allowed\"\n\n# 3. Reasonable magnitudes\nassert mrio.max().max() &lt; 1e12, \"Values seem too large\"\n\n# 4. No empty rows/columns\nassert not (mrio.sum(axis=1) == 0).any(), \"Empty sectors found\"\n</code></pre>"},{"location":"user-guide/input-data/#sector-table-economicsector_tablecsv","title":"Sector Table (<code>Economic/sector_table.csv</code>)","text":"<p>Defines characteristics for each region-sector combination.</p>"},{"location":"user-guide/input-data/#required-columns","title":"Required Columns","text":"<pre><code>sector,type,output,final_demand,usd_per_ton,share_exporting_firms,supply_data,cutoff\nAGR_KHM,agriculture,2000000,500000,950,0.16,ag_prod,3500000\nMAN_KHM,manufacturing,5000000,800000,2864,0.45,man_prod,5000000\nSER_KHM,service,3000000,600000,0,0.10,ser_emp,2000000\n</code></pre>"},{"location":"user-guide/input-data/#column-specifications","title":"Column Specifications","text":"Column Type Description Units Range <code>sector</code> string Region_sector identifier - Must match MRIO <code>type</code> string Sector category - See types below <code>output</code> float Total yearly output Model currency &gt; 0 <code>final_demand</code> float Total yearly final demand Model currency \u2265 0 <code>usd_per_ton</code> float USD value per ton USD/ton \u2265 0 <code>share_exporting_firms</code> float Export participation rate fraction 0-1 <code>supply_data</code> string Spatial disaggregation attribute - Must exist in firms.geojson <code>cutoff</code> float Minimum firm size threshold Model currency \u2265 0"},{"location":"user-guide/input-data/#sector-types","title":"Sector Types","text":"Type Description Transport USD/ton <code>agriculture</code> Farming, fishing, forestry Physical goods &gt; 0 <code>mining</code> Extraction industries Physical goods &gt; 0 <code>manufacturing</code> Processing industries Physical goods &gt; 0 <code>utility</code> Electricity, water, waste Services 0 <code>transport</code> Transport services Services 0 <code>trade</code> Wholesale, retail Services 0 <code>service</code> All other services Services 0 <p>USD per Ton</p> <ul> <li>Set to &gt; 0 for physical goods that are transported</li> <li>Set to 0 for services that don't require physical transport</li> <li>Use UN COMTRADE data for realistic values</li> <li>Typical ranges: 500-5000 USD/ton for most goods</li> </ul>"},{"location":"user-guide/input-data/#firm-level-data-network-mode-only","title":"Firm-Level Data (Network Mode Only)","text":"<p>Required only when using <code>firm_data_type: \"supplier-buyer network\"</code>.</p>"},{"location":"user-guide/input-data/#firm-table-economicfirm_tablecsv","title":"Firm Table (<code>Economic/firm_table.csv</code>)","text":"<pre><code>id,sector,region,output,employees,importance\n1001,AGR_KHM,Phnom_Penh,500000,50,0.15\n1002,AGR_KHM,Siem_Reap,750000,75,0.25\n1003,MAN_KHM,Phnom_Penh,2000000,200,0.45\n</code></pre> Column Description Units <code>id</code> Unique firm identifier integer <code>sector</code> Region_sector code string <code>region</code> Sub-region location string <code>output</code> Annual output model currency <code>employees</code> Number of employees count <code>importance</code> Relative importance weight 0-1"},{"location":"user-guide/input-data/#location-table-economiclocation_tablecsv","title":"Location Table (<code>Economic/location_table.csv</code>)","text":"<pre><code>firm_id,long,lat,transport_node,admin_level1\n1001,-104.532,40.123,node_456,Phnom_Penh\n1002,-104.445,40.234,node_789,Siem_Reap\n1003,-104.612,40.087,node_234,Phnom_Penh\n</code></pre>"},{"location":"user-guide/input-data/#transaction-table-economictransaction_tablecsv","title":"Transaction Table (<code>Economic/transaction_table.csv</code>)","text":"<pre><code>supplier_id,buyer_id,product_sector,transaction,is_essential\n1001,1003,AGR_KHM,150000,true\n1002,1003,AGR_KHM,200000,false\n1004,1003,MAN_THA,500000,true\n</code></pre>"},{"location":"user-guide/input-data/#transport-networks","title":"Transport Networks","text":"<p>All transport files must be GeoJSON with LineString geometry.</p>"},{"location":"user-guide/input-data/#required-files","title":"Required Files","text":""},{"location":"user-guide/input-data/#roads-transportroads_edgesgeojson","title":"Roads (<code>Transport/roads_edges.geojson</code>)","text":"<p>Primary transport network for domestic movements.</p> <pre><code>{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"highway\": \"primary\",\n    \"length_km\": 15.2,\n    \"max_speed\": 80,\n    \"capacity\": 2000\n  },\n  \"geometry\": {\n    \"type\": \"LineString\",\n    \"coordinates\": [[-104.5, 40.1], [-104.4, 40.2]]\n  }\n}\n</code></pre> <p>Required properties: - <code>highway</code> or <code>road_type</code> - Road classification - <code>length_km</code> - Length in kilometers - Optional: <code>max_speed</code>, <code>capacity</code>, <code>surface_type</code></p>"},{"location":"user-guide/input-data/#maritime-transportmaritime_edgesgeojson","title":"Maritime (<code>Transport/maritime_edges.geojson</code>)","text":"<p>International shipping and ferry routes.</p> <pre><code>{\n  \"type\": \"Feature\", \n  \"properties\": {\n    \"route_type\": \"shipping\",\n    \"length_km\": 450.0,\n    \"port_from\": \"Sihanoukville\",\n    \"port_to\": \"Ho_Chi_Minh\"\n  },\n  \"geometry\": {\n    \"type\": \"LineString\",\n    \"coordinates\": [[-103.5, 10.6], [-106.8, 10.8]]\n  }\n}\n</code></pre>"},{"location":"user-guide/input-data/#optional-transport-modes","title":"Optional Transport Modes","text":""},{"location":"user-guide/input-data/#railways-transportrailways_edgesgeojson","title":"Railways (<code>Transport/railways_edges.geojson</code>)","text":"<pre><code>{\n  \"properties\": {\n    \"rail_type\": \"freight\",\n    \"gauge\": \"standard\",\n    \"length_km\": 25.0\n  }\n}\n</code></pre>"},{"location":"user-guide/input-data/#airways-transportairways_edgesgeojson","title":"Airways (<code>Transport/airways_edges.geojson</code>)","text":"<pre><code>{\n  \"properties\": {\n    \"route_type\": \"cargo\",\n    \"airport_from\": \"PNH\", \n    \"airport_to\": \"BKK\",\n    \"length_km\": 400.0\n  }\n}\n</code></pre>"},{"location":"user-guide/input-data/#waterways-transportwaterways_edgesgeojson","title":"Waterways (<code>Transport/waterways_edges.geojson</code>)","text":"<pre><code>{\n  \"properties\": {\n    \"waterway\": \"river\",\n    \"navigable\": true,\n    \"length_km\": 80.0\n  }\n}\n</code></pre>"},{"location":"user-guide/input-data/#pipelines-transportpipelines_edgesgeojson","title":"Pipelines (<code>Transport/pipelines_edges.geojson</code>)","text":"<pre><code>{\n  \"properties\": {\n    \"pipeline_type\": \"oil\",\n    \"diameter_mm\": 600,\n    \"length_km\": 120.0\n  }\n}\n</code></pre>"},{"location":"user-guide/input-data/#multimodal-transportmultimodal_edgesgeojson","title":"Multimodal (<code>Transport/multimodal_edges.geojson</code>)","text":"<p>Connections between different transport modes.</p> <pre><code>{\n  \"properties\": {\n    \"connection_type\": \"port_to_road\",\n    \"from_mode\": \"maritime\",\n    \"to_mode\": \"roads\",\n    \"transfer_time\": 2.0\n  }\n}\n</code></pre>"},{"location":"user-guide/input-data/#transport-network-requirements","title":"Transport Network Requirements","text":"<ol> <li>Connectivity - Network must be connected for routing</li> <li>Coordinate system - Use WGS84 (EPSG:4326)</li> <li>Valid geometry - No self-intersections or invalid coordinates</li> <li>Realistic distances - Length should match geometric distance</li> </ol>"},{"location":"user-guide/input-data/#spatial-data","title":"Spatial Data","text":"<p>Geographic disaggregation files with Point geometry.</p>"},{"location":"user-guide/input-data/#households-spatialhouseholdsgeojson","title":"Households (<code>Spatial/households.geojson</code>)","text":"<p>Population distribution for household placement.</p> <pre><code>{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"region\": \"Phnom_Penh\",\n    \"population\": 15000,\n    \"admin_level1\": \"Phnom_Penh\",\n    \"admin_level2\": \"Khan_Chamkar_Mon\",\n    \"subregion_province\": \"ESMERALDAS\",\n    \"subregion_canton\": \"EL ORO - MACHALA\"\n  },\n  \"geometry\": {\n    \"type\": \"Point\", \n    \"coordinates\": [-104.866, 11.555]\n  }\n}\n</code></pre> <p>Required properties: - <code>region</code> - Region identifier (must match MRIO regions) - <code>population</code> - Population count (optional, defaults to 1)</p> <p>Optional subregion properties: - <code>subregion_*</code> - Hierarchical geographic divisions (must start with <code>subregion_</code> prefix) - Used for filtering agents during disruption scenarios</p>"},{"location":"user-guide/input-data/#countries-spatialcountriesgeojson","title":"Countries (<code>Spatial/countries.geojson</code>)","text":"<p>International trade entry/exit points.</p> <pre><code>{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"region\": \"CHN\",\n    \"entry_type\": \"border_crossing\",\n    \"capacity\": 1000\n  },\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [-104.0, 12.0]\n  }\n}\n</code></pre> <p>Required properties: - <code>region</code> - Country identifier (must match MRIO import/export countries)</p>"},{"location":"user-guide/input-data/#firms-spatialfirmsgeojson","title":"Firms (<code>Spatial/firms.geojson</code>)","text":"<p>Economic activity distribution for firm placement.</p> <pre><code>{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"region\": \"Phnom_Penh\",\n    \"ag_prod\": 150,\n    \"man_prod\": 85,  \n    \"ser_emp\": 200,\n    \"admin_level1\": \"Phnom_Penh\",\n    \"subregion_province\": \"ESMERALDAS\",\n    \"subregion_canton\": \"EL ORO - MACHALA\"\n  },\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [-104.866, 11.555]\n  }\n}\n</code></pre> <p>Required properties: - <code>region</code> - Region identifier (must match MRIO regions) - Sector-specific attributes referenced in <code>sector_table.csv</code> <code>supply_data</code> column</p> <p>Optional subregion properties: - <code>subregion_*</code> - Hierarchical geographic divisions (must start with <code>subregion_</code> prefix) - Examples: <code>subregion_province</code>, <code>subregion_canton</code>, <code>subregion_state</code> - Used for filtering agents during disruption scenarios</p> <p>Sector attribute examples: - <code>ag_prod</code> - Agricultural production value - <code>man_prod</code> - Manufacturing output - <code>min_prod</code> - Mining production - <code>ser_emp</code> - Service employment - <code>pop_density</code> - Population density</p>"},{"location":"user-guide/input-data/#disruption-data-optional","title":"Disruption Data (Optional)","text":""},{"location":"user-guide/input-data/#capital-destruction-disruptioncapital_destructioncsv","title":"Capital Destruction (<code>Disruption/capital_destruction.csv</code>)","text":"<p>Economic damage from disasters.</p> <pre><code>region_sector,capital_destroyed,unit\nAGR_KHM,50000000,USD\nMAN_KHM,120000000,USD\nSER_KHM,30000000,USD\n</code></pre> <p>Columns: - <code>region_sector</code> - Affected sector - <code>capital_destroyed</code> - Damage amount - <code>unit</code> - Currency unit</p>"},{"location":"user-guide/input-data/#transport-disruptions","title":"Transport Disruptions","text":"<p>Specify transport disruptions using edge attributes:</p> <pre><code># In parameter file\nevents:\n  - type: \"transport_disruption\"\n    description_type: \"edge_attributes\"\n    attribute: \"highway\"\n    value: [\"primary\", \"trunk\"]\n    start_time: 10\n    duration: 20\n</code></pre>"},{"location":"user-guide/input-data/#subregion-based-disruptions","title":"Subregion-Based Disruptions","text":"<p>Use subregion attributes for geographic filtering:</p> <pre><code># Capital destruction by province\ndisruptions:\n  - type: capital_destruction\n    description_type: filter\n    filter:\n      subregion_province: ['ESMERALDAS', 'MANABI']  # Filter by province\n    destroyed_capital: 1000.0\n    unit: mUSD\n\n# Productivity shock by canton\n  - type: productivity_shock\n    description_type: filter\n    filter:\n      subregion_canton: ['EL ORO - MACHALA']        # Filter by canton\n    productivity_reduction: 0.3\n    duration: 10\n</code></pre>"},{"location":"user-guide/input-data/#data-preparation-guidelines","title":"Data Preparation Guidelines","text":""},{"location":"user-guide/input-data/#data-sources","title":"Data Sources","text":""},{"location":"user-guide/input-data/#economic-data_1","title":"Economic Data","text":"<ul> <li>National accounts - Statistical offices</li> <li>Input-output tables - OECD, national statistics</li> <li>GTAP database - Global trade data</li> <li>WIOD/EORA - Multi-regional databases</li> </ul>"},{"location":"user-guide/input-data/#transport-networks_1","title":"Transport Networks","text":"<ul> <li>OpenStreetMap - Road networks</li> <li>Natural Earth - Maritime routes</li> <li>National datasets - Railway, pipeline networks</li> <li>Port authorities - Maritime connections</li> </ul>"},{"location":"user-guide/input-data/#spatial-data_1","title":"Spatial Data","text":"<ul> <li>Census data - Population distribution</li> <li>Economic surveys - Firm locations</li> <li>Satellite data - Land use patterns</li> <li>Administrative boundaries - Regional definitions</li> </ul>"},{"location":"user-guide/input-data/#data-processing","title":"Data Processing","text":""},{"location":"user-guide/input-data/#coordinate-systems","title":"Coordinate Systems","text":"<pre><code>import geopandas as gpd\n\n# Ensure WGS84 projection\ngdf = gpd.read_file('transport_data.geojson')\ngdf = gdf.to_crs('EPSG:4326')\ngdf.to_file('transport_edges.geojson', driver='GeoJSON')\n</code></pre>"},{"location":"user-guide/input-data/#unit-conversion","title":"Unit Conversion","text":"<pre><code># Convert currency units\nmrio_usd = mrio_original * 1e6  # Convert mUSD to USD\n\n# Convert distance units  \nlength_km = length_miles * 1.60934\n</code></pre>"},{"location":"user-guide/input-data/#data-validation","title":"Data Validation","text":"<pre><code># Check for missing values\nassert not data.isnull().any().any(), \"Missing values found\"\n\n# Verify coordinate bounds\nassert (gdf.bounds.minx &gt;= -180).all(), \"Invalid longitude\"\nassert (gdf.bounds.maxy &lt;= 90).all(), \"Invalid latitude\"\n\n# Check data types\nassert pd.api.types.is_numeric_dtype(data['output']), \"Output must be numeric\"\n</code></pre>"},{"location":"user-guide/input-data/#quality-assurance","title":"Quality Assurance","text":""},{"location":"user-guide/input-data/#automated-validation","title":"Automated Validation","text":"<p>Run comprehensive validation before simulations:</p> <pre><code>python validate_inputs.py Cambodia --comprehensive\n</code></pre>"},{"location":"user-guide/input-data/#manual-checks","title":"Manual Checks","text":""},{"location":"user-guide/input-data/#economic-consistency","title":"Economic Consistency","text":"<ul> <li>MRIO balance: row sums \u2248 column sums</li> <li>Sector totals match national accounts</li> <li>Reasonable sector shares and ratios</li> </ul>"},{"location":"user-guide/input-data/#spatial-consistency","title":"Spatial Consistency","text":"<ul> <li>Points within country boundaries</li> <li>Transport networks connected</li> <li>Realistic distances and travel times</li> </ul>"},{"location":"user-guide/input-data/#data-completeness","title":"Data Completeness","text":"<ul> <li>All required files present</li> <li>No missing values in critical fields</li> <li>Consistent identifiers across files</li> </ul>"},{"location":"user-guide/input-data/#common-data-issues","title":"Common Data Issues","text":"<p>MRIO Imbalance</p> <p>Problem: Row sums \u2260 column sums Solution: Check aggregation, add balancing items</p> <pre><code># Check balance\nrow_sums = mrio.sum(axis=1)\ncol_sums = mrio.sum(axis=0) \nbalance = (row_sums - col_sums) / row_sums\nprint(f\"Max imbalance: {balance.abs().max():.1%}\")\n</code></pre> <p>Disconnected Networks</p> <p>Problem: Transport network has isolated components Solution: Add connecting edges, check topology</p> <pre><code>import networkx as nx\nG = nx.from_pandas_edgelist(edges, source='from', target='to')\ncomponents = list(nx.connected_components(G))\nprint(f\"Network has {len(components)} components\")\n</code></pre> <p>Coordinate Issues</p> <p>Problem: Invalid or swapped coordinates Solution: Verify coordinate order (lon, lat)</p> <pre><code># Check coordinate bounds\nprint(f\"Longitude range: {gdf.bounds.minx.min():.2f} to {gdf.bounds.maxx.max():.2f}\")\nprint(f\"Latitude range: {gdf.bounds.miny.min():.2f} to {gdf.bounds.maxy.max():.2f}\")\n</code></pre>"},{"location":"user-guide/input-data/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/input-data/#data-management","title":"Data Management","text":"<ol> <li>Version control - Track data changes with git LFS</li> <li>Documentation - Record data sources and processing steps</li> <li>Backup - Maintain copies of original raw data</li> <li>Validation - Always validate before production runs</li> </ol>"},{"location":"user-guide/input-data/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>File sizes - Keep GeoJSON files under 50MB when possible</li> <li>Precision - Round coordinates to appropriate precision (5-6 decimal places)</li> <li>Compression - Use gzip for large CSV files</li> <li>Indexing - Ensure proper indexing for database files</li> </ol>"},{"location":"user-guide/input-data/#collaboration","title":"Collaboration","text":"<ol> <li>Standards - Follow consistent naming conventions</li> <li>Metadata - Include data dictionaries and README files</li> <li>Access - Use appropriate data sharing mechanisms</li> <li>Privacy - Ensure compliance with data protection regulations</li> </ol>"},{"location":"user-guide/output-files/","title":"Output Files","text":"<p>DisruptSC generates comprehensive output data for analysis and visualization. This guide explains all output files and how to use them.</p>"},{"location":"user-guide/output-files/#output-structure","title":"Output Structure","text":"<p>Results are saved in timestamped directories:</p> <pre><code>output/&lt;scope&gt;/&lt;timestamp&gt;/\n\u251c\u2500\u2500 Time Series Data\n\u2502   \u251c\u2500\u2500 firm_data.json\n\u2502   \u251c\u2500\u2500 household_data.json\n\u2502   \u251c\u2500\u2500 country_data.json\n\u2502   \u2514\u2500\u2500 flow_df_*.csv\n\u251c\u2500\u2500 Spatial Data\n\u2502   \u251c\u2500\u2500 firm_table.geojson\n\u2502   \u251c\u2500\u2500 household_table.geojson\n\u2502   \u2514\u2500\u2500 transport_edges_with_flows_*.geojson\n\u251c\u2500\u2500 Network Data\n\u2502   \u251c\u2500\u2500 sc_network_edgelist.csv\n\u2502   \u2514\u2500\u2500 io_table.csv\n\u251c\u2500\u2500 Analysis Results\n\u2502   \u251c\u2500\u2500 loss_per_country.csv\n\u2502   \u251c\u2500\u2500 loss_per_region_sector_time.csv\n\u2502   \u251c\u2500\u2500 loss_summary.csv\n\u2502   \u2514\u2500\u2500 sensitivity_*.csv          # Sensitivity analysis only\n\u2514\u2500\u2500 Metadata\n    \u251c\u2500\u2500 parameters.yaml\n    \u2514\u2500\u2500 exp.log\n</code></pre>"},{"location":"user-guide/output-files/#time-series-data","title":"Time Series Data","text":""},{"location":"user-guide/output-files/#firm-data-firm_datajson","title":"Firm Data (<code>firm_data.json</code>)","text":"<p>Agent-level time series for all firms.</p>"},{"location":"user-guide/output-files/#structure","title":"Structure","text":"<pre><code>{\n  \"production\": {\n    \"0\": {\"1001\": 500000, \"1002\": 750000, \"1003\": 2000000},\n    \"1\": {\"1001\": 480000, \"1002\": 720000, \"1003\": 1900000},\n    \"2\": {\"1001\": 450000, \"1002\": 690000, \"1003\": 1800000}\n  },\n  \"inventory\": {\n    \"AGR_KHM\": {\n      \"0\": {\"1001\": 50000, \"1002\": 75000},\n      \"1\": {\"1001\": 45000, \"1002\": 70000}\n    }\n  },\n  \"finance\": {\n    \"0\": {\"1001\": 100000, \"1002\": 150000, \"1003\": 400000}\n  }\n}\n</code></pre>"},{"location":"user-guide/output-files/#key-variables","title":"Key Variables","text":"Variable Description Units <code>production</code> Output produced per time step Model currency <code>production_target</code> Planned production Model currency <code>product_stock</code> Finished goods inventory Model currency <code>inventory</code> Input inventories by sector Model currency <code>purchase_plan</code> Planned purchases by supplier Model currency <code>finance</code> Financial position Model currency <code>profit</code> Profit/loss per time step Model currency"},{"location":"user-guide/output-files/#analysis-examples","title":"Analysis Examples","text":"<pre><code>import json\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load firm data\nwith open('firm_data.json', 'r') as f:\n    firm_data = json.load(f)\n\n# Convert to DataFrame\nproduction_df = pd.DataFrame(firm_data['production']).T\nproduction_df.index = production_df.index.astype(int)\n\n# Plot total production over time\ntotal_production = production_df.sum(axis=1)\ntotal_production.plot(title='Total Production Over Time')\nplt.ylabel('Production (Model Currency)')\nplt.xlabel('Time Step')\nplt.show()\n\n# Calculate production losses\nbaseline = total_production.iloc[0]\nlosses = baseline - total_production\ncumulative_loss = losses.cumsum()\n\nprint(f\"Peak loss: {losses.max():.0f}\")\nprint(f\"Total cumulative loss: {cumulative_loss.iloc[-1]:.0f}\")\n</code></pre>"},{"location":"user-guide/output-files/#household-data-household_datajson","title":"Household Data (<code>household_data.json</code>)","text":"<p>Consumption patterns and welfare impacts.</p>"},{"location":"user-guide/output-files/#structure_1","title":"Structure","text":"<pre><code>{\n  \"consumption\": {\n    \"0\": {\"hh_1\": 15000, \"hh_2\": 22000},\n    \"1\": {\"hh_1\": 14500, \"hh_2\": 21000}\n  },\n  \"spending\": {\n    \"0\": {\"hh_1\": 15000, \"hh_2\": 22000},\n    \"1\": {\"hh_1\": 15200, \"hh_2\": 22500}\n  },\n  \"consumption_loss\": {\n    \"0\": {\"hh_1\": 0, \"hh_2\": 0},\n    \"1\": {\"hh_1\": 500, \"hh_2\": 1000}\n  }\n}\n</code></pre>"},{"location":"user-guide/output-files/#key-variables_1","title":"Key Variables","text":"Variable Description Units <code>consumption</code> Goods/services consumed Model currency <code>spending</code> Total expenditure Model currency <code>consumption_loss</code> Unmet demand Model currency <code>extra_spending</code> Price increase impacts Model currency"},{"location":"user-guide/output-files/#country-data-country_datajson","title":"Country Data (<code>country_data.json</code>)","text":"<p>International trade impacts.</p>"},{"location":"user-guide/output-files/#structure_2","title":"Structure","text":"<pre><code>{\n  \"exports\": {\n    \"0\": {\"CHN\": 500000, \"THA\": 300000},\n    \"1\": {\"CHN\": 480000, \"THA\": 290000}\n  },\n  \"imports\": {\n    \"0\": {\"CHN\": 200000, \"THA\": 150000}\n  }\n}\n</code></pre>"},{"location":"user-guide/output-files/#transport-flows-flow_df_csv","title":"Transport Flows (<code>flow_df_*.csv</code>)","text":"<p>Detailed transport flow data by time step.</p> <pre><code>edge_id,from_node,to_node,transport_mode,flow_volume,flow_value,travel_time\nedge_001,node_123,node_456,roads,1500,750000,2.5\nedge_002,node_456,node_789,roads,800,400000,1.8\nedge_003,port_001,port_002,maritime,5000,2500000,24.0\n</code></pre>"},{"location":"user-guide/output-files/#columns","title":"Columns","text":"Column Description Units <code>edge_id</code> Transport link identifier - <code>from_node</code> Origin node - <code>to_node</code> Destination node - <code>transport_mode</code> Mode of transport - <code>flow_volume</code> Physical flow volume Tons <code>flow_value</code> Economic value Model currency <code>travel_time</code> Transit time Hours"},{"location":"user-guide/output-files/#spatial-data","title":"Spatial Data","text":""},{"location":"user-guide/output-files/#firm-locations-firm_tablegeojson","title":"Firm Locations (<code>firm_table.geojson</code>)","text":"<p>Spatial firm data with attributes and results.</p> <pre><code>{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"pid\": 1001,\n    \"sector\": \"AGR_KHM\",\n    \"region\": \"Phnom_Penh\",\n    \"eq_production\": 500000,\n    \"final_production\": 450000,\n    \"production_loss\": 50000,\n    \"importance\": 0.15\n  },\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [-104.866, 11.555]\n  }\n}\n</code></pre>"},{"location":"user-guide/output-files/#key-attributes","title":"Key Attributes","text":"Attribute Description Type <code>pid</code> Firm identifier integer <code>sector</code> Region_sector code string <code>eq_production</code> Baseline production float <code>final_production</code> End production float <code>production_loss</code> Total impact float <code>importance</code> Economic importance float"},{"location":"user-guide/output-files/#household-locations-household_tablegeojson","title":"Household Locations (<code>household_table.geojson</code>)","text":"<p>Spatial household data with consumption impacts.</p> <pre><code>{\n  \"properties\": {\n    \"pid\": \"hh_1\",\n    \"region\": \"Phnom_Penh\", \n    \"population\": 15000,\n    \"baseline_consumption\": 150000,\n    \"final_consumption\": 145000,\n    \"consumption_loss\": 5000,\n    \"extra_spending\": 2000\n  }\n}\n</code></pre>"},{"location":"user-guide/output-files/#transport-flows-transport_edges_with_flows_geojson","title":"Transport Flows (<code>transport_edges_with_flows_*.geojson</code>)","text":"<p>Network visualization with flow data.</p> <pre><code>{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"edge_id\": \"edge_001\",\n    \"highway\": \"primary\",\n    \"length_km\": 15.2,\n    \"baseline_flow\": 1500,\n    \"disrupted_flow\": 1200,\n    \"flow_reduction\": 300,\n    \"utilization\": 0.75\n  },\n  \"geometry\": {\n    \"type\": \"LineString\",\n    \"coordinates\": [[-104.5, 11.1], [-104.4, 11.2]]\n  }\n}\n</code></pre>"},{"location":"user-guide/output-files/#visualization-example","title":"Visualization Example","text":"<pre><code>import geopandas as gpd\nimport matplotlib.pyplot as plt\nimport contextily as ctx\n\n# Load transport flows\nflows = gpd.read_file('transport_edges_with_flows_0.geojson')\nflows = flows.to_crs(epsg=3857)  # Web Mercator for basemap\n\n# Create map\nfig, ax = plt.subplots(figsize=(12, 8))\n\n# Plot flows with width proportional to volume\nflows.plot(\n    ax=ax,\n    linewidth=flows['baseline_flow']/1000,\n    color='red',\n    alpha=0.7,\n    label='Transport Flows'\n)\n\n# Add basemap\nctx.add_basemap(ax, crs=flows.crs, source=ctx.providers.OpenStreetMap.Mapnik)\n\nplt.title('Transport Network Utilization')\nplt.legend()\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/output-files/#network-data","title":"Network Data","text":""},{"location":"user-guide/output-files/#supply-chain-network-sc_network_edgelistcsv","title":"Supply Chain Network (<code>sc_network_edgelist.csv</code>)","text":"<p>Complete supply chain relationships.</p> <pre><code>supplier_id,buyer_id,supplier_type,buyer_type,product,weight,baseline_flow\n1001,1003,firm,firm,AGR_KHM,0.25,150000\n1002,1003,firm,firm,AGR_KHM,0.35,200000\nCHN,1003,country,firm,MAN_CHN,0.40,500000\n1003,hh_1,firm,household,MAN_KHM,0.15,75000\n</code></pre>"},{"location":"user-guide/output-files/#columns_1","title":"Columns","text":"Column Description <code>supplier_id</code> Supplier identifier <code>buyer_id</code> Buyer identifier <code>supplier_type</code> Agent type (firm/country/household) <code>buyer_type</code> Agent type <code>product</code> Product/sector traded <code>weight</code> Relationship strength <code>baseline_flow</code> Economic flow value"},{"location":"user-guide/output-files/#input-output-table-io_tablecsv","title":"Input-Output Table (<code>io_table.csv</code>)","text":"<p>Realized input-output flows.</p> <pre><code>,AGR_KHM,MAN_KHM,SER_KHM,HH_KHM,Export_CHN\nAGR_KHM,50000,150000,25000,500000,100000\nMAN_KHM,75000,200000,150000,800000,150000\nSER_KHM,25000,100000,300000,600000,50000\n</code></pre>"},{"location":"user-guide/output-files/#analysis-results","title":"Analysis Results","text":""},{"location":"user-guide/output-files/#loss-summary-loss_summarycsv","title":"Loss Summary (<code>loss_summary.csv</code>)","text":"<p>Aggregate impact metrics.</p> <pre><code>metric,value,unit,description\ntotal_production_loss,250000000,USD,Cumulative production loss\npeak_production_loss,15000000,USD,Maximum single-period loss\naffected_firms,1250,count,Firms with production loss &gt; 0\ntotal_consumption_loss,50000000,USD,Unmet household demand\nwelfare_loss,75000000,USD,Consumer welfare impact\nrecovery_time,45,days,Time to 95% recovery\n</code></pre>"},{"location":"user-guide/output-files/#sensitivity-analysis-sensitivity_csv","title":"Sensitivity Analysis (<code>sensitivity_*.csv</code>)","text":"<p>Parameter sensitivity results from <code>disruption-sensitivity</code> simulations.</p>"},{"location":"user-guide/output-files/#structure_3","title":"Structure","text":"<pre><code>combination_id,io_cutoff,utilization,inventory_duration_targets.values.transport,household_loss,country_loss\n0,0.01,0.8,1,1250000.5,890000.2\n1,0.01,0.8,3,1180000.1,850000.8\n2,0.01,0.8,5,1120000.9,820000.4\n3,0.01,1.0,1,1180000.3,850000.1\n4,0.01,1.0,3,1100000.7,810000.5\n5,0.01,1.0,5,1050000.2,780000.3\n6,0.1,0.8,1,980000.1,720000.8\n7,0.1,0.8,3,920000.5,690000.2\n8,0.1,0.8,5,890000.3,670000.1\n9,0.1,1.0,1,950000.8,700000.4\n10,0.1,1.0,3,900000.2,680000.7\n11,0.1,1.0,5,870000.1,660000.2\n</code></pre>"},{"location":"user-guide/output-files/#columns_2","title":"Columns","text":"<ul> <li><code>combination_id</code> - Sequential identifier for parameter combination</li> <li>Parameter columns - One column per sensitivity parameter (dynamic)</li> <li><code>household_loss</code> - Final household economic loss (model currency)</li> <li><code>country_loss</code> - Final country trade loss (model currency)</li> </ul>"},{"location":"user-guide/output-files/#analysis-example","title":"Analysis Example","text":"<pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load sensitivity results\ndf = pd.read_csv('sensitivity_20240101_120000.csv')\n\n# Analyze io_cutoff impact\ncutoff_impact = df.groupby('io_cutoff')['household_loss'].mean()\nprint(\"Average household loss by IO cutoff:\")\nprint(cutoff_impact)\n\n# Plot parameter sensitivity\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\n\n# IO cutoff sensitivity\ndf.boxplot(column='household_loss', by='io_cutoff', ax=axes[0])\naxes[0].set_title('Household Loss vs IO Cutoff')\n\n# Utilization sensitivity  \ndf.boxplot(column='household_loss', by='utilization', ax=axes[1])\naxes[1].set_title('Household Loss vs Utilization')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/output-files/#regional-impacts-loss_per_region_sector_timecsv","title":"Regional Impacts (<code>loss_per_region_sector_time.csv</code>)","text":"<p>Detailed spatio-temporal analysis.</p> <pre><code>time,region,sector,production_loss,consumption_loss,employment_impact\n0,Phnom_Penh,AGR_KHM,0,0,0\n1,Phnom_Penh,AGR_KHM,500000,100000,50\n2,Phnom_Penh,AGR_KHM,750000,150000,75\n1,Siem_Reap,AGR_KHM,200000,50000,25\n</code></pre>"},{"location":"user-guide/output-files/#country-impacts-loss_per_countrycsv","title":"Country Impacts (<code>loss_per_country.csv</code>)","text":"<p>International trade effects.</p> <pre><code>country,export_loss,import_disruption,trade_diversion,total_impact\nCHN,25000000,15000000,5000000,45000000\nTHA,10000000,8000000,2000000,20000000\nVNM,5000000,3000000,1000000,9000000\n</code></pre>"},{"location":"user-guide/output-files/#metadata-files","title":"Metadata Files","text":""},{"location":"user-guide/output-files/#parameters-parametersyaml","title":"Parameters (<code>parameters.yaml</code>)","text":"<p>Complete configuration snapshot.</p> <pre><code># Simulation configuration\nsimulation_type: \"disruption\"\nscope: \"Cambodia\"\ntimestamp: \"20241201_143022\"\n\n# Economic parameters\nio_cutoff: 0.01\nmonetary_units_in_model: \"mUSD\"\n\n# Events applied\nevents:\n  - type: \"transport_disruption\"\n    start_time: 10\n    duration: 20\n\n# Performance metrics\nruntime_seconds: 3450\nmemory_peak_gb: 8.2\n</code></pre>"},{"location":"user-guide/output-files/#execution-log-explog","title":"Execution Log (<code>exp.log</code>)","text":"<p>Detailed execution information.</p> <pre><code>2024-12-01 14:30:22 INFO    Starting DisruptSC simulation for Cambodia\n2024-12-01 14:30:25 INFO    Loading transport network... \n2024-12-01 14:31:15 INFO    Transport network loaded: 15,234 edges, 8,567 nodes\n2024-12-01 14:31:20 INFO    Creating firms...\n2024-12-01 14:32:45 INFO    Created 2,456 firms across 15 sectors\n2024-12-01 14:35:12 INFO    Supply chain network created: 45,678 links\n2024-12-01 14:42:30 INFO    Starting simulation...\n2024-12-01 14:42:31 INFO    Time step 0: baseline state established\n2024-12-01 14:42:45 INFO    Time step 10: applying transport disruption\n2024-12-01 14:43:12 WARNING Transport disruption affecting 125 edges\n2024-12-01 14:58:45 INFO    Simulation completed in 26m 23s\n</code></pre>"},{"location":"user-guide/output-files/#data-analysis-workflows","title":"Data Analysis Workflows","text":""},{"location":"user-guide/output-files/#quick-impact-assessment","title":"Quick Impact Assessment","text":"<pre><code>import pandas as pd\nimport numpy as np\n\n# Load key results\nloss_summary = pd.read_csv('loss_summary.csv', index_col='metric')\nregional_losses = pd.read_csv('loss_per_region_sector_time.csv')\n\n# Key metrics\ntotal_loss = loss_summary.loc['total_production_loss', 'value']\npeak_loss = loss_summary.loc['peak_production_loss', 'value']\nrecovery_time = loss_summary.loc['recovery_time', 'value']\n\nprint(f\"Total economic impact: ${total_loss:,.0f}\")\nprint(f\"Peak daily loss: ${peak_loss:,.0f}\")\nprint(f\"Recovery time: {recovery_time} days\")\n\n# Regional breakdown\nregional_totals = regional_losses.groupby('region')['production_loss'].sum().sort_values(ascending=False)\nprint(\"\\nMost affected regions:\")\nprint(regional_totals.head())\n</code></pre>"},{"location":"user-guide/output-files/#sector-analysis","title":"Sector Analysis","text":"<pre><code># Sector vulnerability analysis\nsector_impacts = regional_losses.groupby(['sector', 'time'])['production_loss'].sum().unstack(level=0)\n\n# Plot sector impacts over time\nsector_impacts.plot(figsize=(12, 6), title='Production Loss by Sector Over Time')\nplt.ylabel('Production Loss')\nplt.xlabel('Time Step')\nplt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.show()\n\n# Identify most vulnerable sectors\nvulnerability = sector_impacts.max().sort_values(ascending=False)\nprint(\"Most vulnerable sectors:\")\nprint(vulnerability.head())\n</code></pre>"},{"location":"user-guide/output-files/#spatial-analysis","title":"Spatial Analysis","text":"<pre><code>import geopandas as gpd\nfrom shapely.geometry import Point\n\n# Load spatial results\nfirms = gpd.read_file('firm_table.geojson')\n\n# Calculate loss rates\nfirms['loss_rate'] = firms['production_loss'] / firms['eq_production']\n\n# Create map of impacts\nfig, ax = plt.subplots(figsize=(10, 8))\nfirms.plot(\n    column='loss_rate',\n    ax=ax,\n    cmap='Reds',\n    legend=True,\n    markersize=firms['importance']*100,\n    alpha=0.7\n)\nplt.title('Production Loss Rate by Firm')\nplt.xlabel('Longitude')\nplt.ylabel('Latitude')\nplt.show()\n\n# Hotspot analysis\nhigh_impact = firms[firms['loss_rate'] &gt; 0.2]  # &gt;20% loss\nprint(f\"High-impact firms: {len(high_impact)}\")\nprint(f\"Average impact: {high_impact['loss_rate'].mean():.1%}\")\n</code></pre>"},{"location":"user-guide/output-files/#network-analysis","title":"Network Analysis","text":"<pre><code>import networkx as nx\n\n# Load supply chain network\nsc_network = pd.read_csv('sc_network_edgelist.csv')\n\n# Create network graph\nG = nx.from_pandas_edgelist(\n    sc_network, \n    source='supplier_id', \n    target='buyer_id',\n    edge_attr='weight'\n)\n\n# Network metrics\nprint(f\"Nodes: {G.number_of_nodes()}\")\nprint(f\"Edges: {G.number_of_edges()}\")\nprint(f\"Density: {nx.density(G):.3f}\")\n\n# Centrality analysis\ncentrality = nx.betweenness_centrality(G)\ntop_central = sorted(centrality.items(), key=lambda x: x[1], reverse=True)[:10]\n\nprint(\"\\nMost central agents:\")\nfor agent, score in top_central:\n    print(f\"{agent}: {score:.3f}\")\n</code></pre>"},{"location":"user-guide/output-files/#performance-and-optimization","title":"Performance and Optimization","text":""},{"location":"user-guide/output-files/#file-size-management","title":"File Size Management","text":"<p>Large output files can impact performance:</p> <pre><code>import os\n\ndef check_file_sizes(output_dir):\n    \"\"\"Check output file sizes.\"\"\"\n    for root, dirs, files in os.walk(output_dir):\n        for file in files:\n            filepath = os.path.join(root, file)\n            size_mb = os.path.getsize(filepath) / (1024*1024)\n            if size_mb &gt; 100:  # Files &gt; 100MB\n                print(f\"Large file: {file} ({size_mb:.1f} MB)\")\n\ncheck_file_sizes('output/Cambodia/latest/')\n</code></pre>"},{"location":"user-guide/output-files/#memory-efficient-loading","title":"Memory-Efficient Loading","text":"<p>For large datasets:</p> <pre><code># Load data in chunks\ndef load_large_csv(filepath, chunksize=10000):\n    \"\"\"Load large CSV files in chunks.\"\"\"\n    chunks = []\n    for chunk in pd.read_csv(filepath, chunksize=chunksize):\n        # Process chunk\n        processed = chunk.groupby('region').sum()\n        chunks.append(processed)\n    return pd.concat(chunks)\n\n# Use generators for JSON\ndef load_time_series(filepath):\n    \"\"\"Generator for time series data.\"\"\"\n    with open(filepath, 'r') as f:\n        data = json.load(f)\n\n    for variable, time_series in data.items():\n        yield variable, pd.DataFrame(time_series)\n</code></pre>"},{"location":"user-guide/output-files/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/output-files/#data-management","title":"Data Management","text":"<ol> <li>Archive results - Copy important runs to permanent storage</li> <li>Document analysis - Save analysis scripts with results</li> <li>Version tracking - Record model version and parameters</li> <li>Compression - Compress large output directories</li> </ol>"},{"location":"user-guide/output-files/#reproducibility","title":"Reproducibility","text":"<ol> <li>Save parameters - Always archive the <code>parameters.yaml</code> file</li> <li>Record environment - Document software versions</li> <li>Analysis scripts - Version control analysis code</li> <li>Data lineage - Track input data sources and versions</li> </ol>"},{"location":"user-guide/output-files/#visualization","title":"Visualization","text":"<ol> <li>Consistent scales - Use same scales for comparison</li> <li>Color schemes - Choose appropriate colormaps</li> <li>Interactive maps - Use Folium/Plotly for web maps</li> <li>Export formats - Save plots in vector formats (SVG/PDF)</li> </ol>"},{"location":"user-guide/output-files/#performance","title":"Performance","text":"<ol> <li>Selective loading - Only load needed variables</li> <li>Spatial indexing - Use spatial indices for large datasets</li> <li>Parallel processing - Use multiprocessing for analysis</li> <li>Memory monitoring - Track memory usage during analysis</li> </ol>"},{"location":"user-guide/parameters/","title":"Parameters","text":"<p>DisruptSC uses a hierarchical configuration system with YAML files. This guide explains all available parameters and their usage.</p>"},{"location":"user-guide/parameters/#configuration-system","title":"Configuration System","text":""},{"location":"user-guide/parameters/#file-hierarchy","title":"File Hierarchy","text":"<ol> <li><code>parameter/default.yaml</code> - Base parameters (don't edit)</li> <li><code>parameter/user_defined_&lt;scope&gt;.yaml</code> - Scope-specific overrides</li> </ol> <p>Only edit the user-defined files. Default parameters are loaded first, then overridden by user settings.</p>"},{"location":"user-guide/parameters/#parameter-override","title":"Parameter Override","text":"<pre><code># parameter/user_defined_Cambodia.yaml\nsimulation_type: \"disruption\"    # Override default\nio_cutoff: 0.05                 # Override default\n# Other parameters inherit from default.yaml\n</code></pre>"},{"location":"user-guide/parameters/#command-line-overrides","title":"Command Line Overrides","text":"<p>Key parameters can be overridden from command line:</p> <pre><code>python disruptsc/main.py Cambodia --io_cutoff 0.05 --duration 90\n</code></pre>"},{"location":"user-guide/parameters/#core-simulation-parameters","title":"Core Simulation Parameters","text":""},{"location":"user-guide/parameters/#simulation-control","title":"Simulation Control","text":"<pre><code># Simulation type and duration\nsimulation_type: \"initial_state\"  # See options below\nt_final: 365                      # Simulation duration (time units)\ntime_resolution: \"day\"            # Time unit: \"day\", \"week\", \"month\"\nepsilon_stop_condition: true      # Stop when equilibrium reached\n</code></pre> <p>Simulation Types:</p> Type Purpose When to Use <code>initial_state</code> Baseline analysis Understanding normal operations <code>disruption</code> Single disruption Testing specific scenarios <code>disruption_mc</code> Monte Carlo analysis Statistical robustness <code>criticality</code> Infrastructure assessment Finding critical links <code>disruption-sensitivity</code> Parameter sensitivity Testing parameter robustness <code>flow_calibration</code> Transport calibration Matching observed data"},{"location":"user-guide/parameters/#scope-and-regions","title":"Scope and Regions","text":"<pre><code>scope: \"Cambodia\"                 # Main study region\n</code></pre>"},{"location":"user-guide/parameters/#data-configuration","title":"Data Configuration","text":""},{"location":"user-guide/parameters/#data-sources","title":"Data Sources","text":"<pre><code># Data input mode\nfirm_data_type: \"mrio\"           # \"mrio\" or \"supplier-buyer network\"\n\n# Monetary units\nmonetary_units_in_model: \"mUSD\"   # Model currency: \"USD\", \"kUSD\", \"mUSD\"\nmonetary_units_in_data: \"USD\"    # Data currency: \"USD\", \"kUSD\", \"mUSD\"\n\n# File paths (relative to data folder)\nfilepaths:\n  mrio: \"Economic/mrio.csv\"\n  sector_table: \"Economic/sector_table.csv\"\n  households_spatial: \"Spatial/households.geojson\"\n  firms_spatial: \"Spatial/firms.geojson\"\n  countries_spatial: \"Spatial/countries.geojson\"\n  # Transport networks\n  roads_edges: \"Transport/roads_edges.geojson\"\n  maritime_edges: \"Transport/maritime_edges.geojson\"\n  railways_edges: \"Transport/railways_edges.geojson\"\n  # Additional files for supplier-buyer mode\n  firm_table: \"Economic/firm_table.csv\"\n  location_table: \"Economic/location_table.csv\"\n  transaction_table: \"Economic/transaction_table.csv\"\n</code></pre>"},{"location":"user-guide/parameters/#data-filtering","title":"Data Filtering","text":"<pre><code># Economic thresholds\nio_cutoff: 0.01                  # Input-output coefficient threshold\ncutoff_firm_output:\n  value: 1000000                 # Minimum firm output\n  unit: \"USD\"                    # Unit for threshold\ncutoff_sector_output:\n  value: 50000000                # Minimum sector output\n  unit: \"USD\"\ncutoff_household_demand:\n  value: 100                     # Minimum household demand\n  unit: \"USD\"\n\n# Sector filtering\nsectors_to_include: []           # Empty = include all\nsectors_to_exclude: []           # Empty = exclude none\n# Example: [\"AGR\", \"MAN\"] or [\"SER_*\"] (wildcards supported)\n\n# Regional filtering  \ncountries_to_include: []         # Empty = include all trading partners\n</code></pre>"},{"location":"user-guide/parameters/#agent-parameters","title":"Agent Parameters","text":""},{"location":"user-guide/parameters/#firm-behavior","title":"Firm Behavior","text":"<pre><code># Production parameters\nutilization_rate: 0.8            # Normal capacity utilization\ncapital_to_value_added_ratio: 4  # Capital intensity\ninventory_restoration_time: 1    # Inventory rebuild speed (time units)\n\n# Inventory management\ninventory_duration_targets:\n  default: 7                     # Days of inventory to maintain\n  AGR: 3                        # Sector-specific overrides\n  MAN: 14\n  SER: 1\n\n# Financial parameters\ntarget_margin: 0.2               # Profit margin target\ntransport_share: 0.2             # Transport cost share of output\n</code></pre>"},{"location":"user-guide/parameters/#supply-chain-formation","title":"Supply Chain Formation","text":"<pre><code># Supplier selection\nnb_suppliers_per_input: 1.5      # Average suppliers per input (1-2)\nweight_localization_firm: 2.0    # Distance preference (higher = more local)\nweight_localization_household: 1.5  # Household retailer distance preference\n\n# Market behavior\nadaptive_inventories: true       # Adjust inventory targets\nadaptive_supplier_weight: true   # Change supplier preferences\nrationing_mode: \"equal\"          # How to allocate scarce supplies\n</code></pre>"},{"location":"user-guide/parameters/#transport-parameters","title":"Transport Parameters","text":""},{"location":"user-guide/parameters/#transport-modeling","title":"Transport Modeling","text":"<pre><code># Transport system\nwith_transport: true             # Enable transport modeling\ntransport_modes: [\"roads\", \"maritime\", \"railways\"]  # Active modes\ntransport_to_households: false   # Model household transport explicitly\nsectors_no_transport_network: [\"SER\", \"UTI\"]  # Service sectors\n\n# Performance and routing\ncapacity_constraint: false       # Enable transport capacity limits\nuse_route_cache: true           # Cache routing calculations\nroute_optimization_weight: \"time\"  # Optimization criteria\ncongestion: false               # Enable congestion modeling\n</code></pre>"},{"location":"user-guide/parameters/#transport-economics","title":"Transport Economics","text":"<pre><code># Cost parameters\nprice_increase_threshold: 0.5    # Maximum price increase tolerance\n\n# Logistics parameters\nlogistics:\n  nb_cost_profiles: 3            # Number of different cost profiles\n  sector_types_to_shipment_method:\n    agriculture: \"bulk\"\n    manufacturing: \"container\" \n    service: \"express\"\n</code></pre>"},{"location":"user-guide/parameters/#disruption-parameters","title":"Disruption Parameters","text":""},{"location":"user-guide/parameters/#event-configuration","title":"Event Configuration","text":"<pre><code># Disruption events\nevents:\n  - type: \"transport_disruption\"\n    description_type: \"edge_attributes\"\n    attribute: \"highway\"          # Edge attribute to match\n    value: [\"primary\", \"trunk\"]   # Values indicating disruption\n    start_time: 10               # When disruption starts\n    duration: 20                 # How long it lasts\n\n  - type: \"capital_destruction\"\n    description_type: \"region_sector_file\"\n    region_sector_filepath: \"Disruption/earthquake_damage.csv\"\n    unit: \"mUSD\"\n    reconstruction_market: true   # Enable reconstruction\n    start_time: 5\n</code></pre>"},{"location":"user-guide/parameters/#recovery-parameters","title":"Recovery Parameters","text":"<pre><code># Recovery modeling\nrecovery:\n  transport_recovery_rate: 0.1   # Daily recovery rate (0-1)\n  capital_recovery_rate: 0.05    # Capital rebuilding rate\n  adaptive_recovery: true        # Priority-based recovery\n</code></pre>"},{"location":"user-guide/parameters/#criticality-analysis","title":"Criticality Analysis","text":"<pre><code>criticality:\n  duration: 30                   # Days to simulate each disruption\n  edges_to_test: \"all\"          # \"all\", \"primary\", or specific list\n  metrics: [\"production_loss\", \"welfare_loss\"]  # Impact measures\n</code></pre>"},{"location":"user-guide/parameters/#performance-parameters","title":"Performance Parameters","text":""},{"location":"user-guide/parameters/#computational-settings","title":"Computational Settings","text":"<pre><code># Execution control\nlogging_level: \"INFO\"            # \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"\nexport_files: true              # Save detailed outputs\nflow_data: true                 # Export transport flow data\n\n# Parallel processing\nparallelized: false             # Enable parallel route calculation\nmax_workers: 4                  # Number of parallel workers\n\n# Memory management\ncache_size: 1000                # Route cache size\nbatch_size: 100                 # Processing batch size\n</code></pre>"},{"location":"user-guide/parameters/#monte-carlo-settings","title":"Monte Carlo Settings","text":"<pre><code># Monte Carlo analysis\nmc_repetitions: 100             # Number of MC runs\nmc_seed: 42                     # Random seed for reproducibility\nmc_parallel: true              # Parallel MC execution\nmc_output_aggregation: \"summary\"  # \"full\", \"summary\", \"minimal\"\n</code></pre>"},{"location":"user-guide/parameters/#sensitivity-analysis-settings","title":"Sensitivity Analysis Settings","text":"<pre><code># Parameter sensitivity analysis\nsimulation_type: \"disruption-sensitivity\"\nsensitivity:\n  io_cutoff: [0.01, 0.05, 0.1]                    # Economic threshold values\n  utilization: [0.8, 0.9, 1.0]                    # Transport capacity utilization\n  inventory_duration_targets.values.transport: [1, 3, 5]  # Inventory targets (nested)\n  price_increase_threshold: [0.05, 0.1, 0.15]     # Price shock thresholds\n</code></pre> <p>Sensitivity Configuration:</p> <ul> <li>Parameter specification: List all values to test for each parameter</li> <li>Nested parameters: Use dot notation (e.g., <code>parent.child.property</code>)</li> <li>Cartesian product: All combinations are automatically generated</li> <li>Output: Single CSV file with results for each combination</li> <li>No caching: Each combination rebuilds the complete model</li> </ul> <p>Example with 3\u00d73\u00d73\u00d73 = 81 combinations: <pre><code>sensitivity:\n  io_cutoff: [0.01, 0.05, 0.1]\n  utilization: [0.8, 0.9, 1.0] \n  price_increase_threshold: [0.05, 0.1, 0.15]\n  inventory_duration_targets.values.transport: [1, 3, 5]\n</code></pre></p>"},{"location":"user-guide/parameters/#advanced-parameters","title":"Advanced Parameters","text":""},{"location":"user-guide/parameters/#model-calibration","title":"Model Calibration","text":"<pre><code># Calibration targets\ncalibration:\n  target_flows: \"observed_flows.csv\"  # Observed transport data\n  target_prices: \"price_data.csv\"     # Market price data\n  weight_flows: 0.7                   # Relative importance of flow matching\n  weight_prices: 0.3                  # Relative importance of price matching\n  max_iterations: 50                  # Calibration iterations\n  tolerance: 0.01                     # Convergence tolerance\n</code></pre>"},{"location":"user-guide/parameters/#experimental-features","title":"Experimental Features","text":"<pre><code># Advanced features (experimental)\nexplicit_service_firm: false    # Explicit service firm modeling\ncongestion_modeling: false      # Traffic congestion effects\nprice_dynamics: false          # Dynamic price adjustment\nfirm_entry_exit: false         # Firm birth/death processes\nlearning_effects: false        # Adaptive agent behavior\n</code></pre>"},{"location":"user-guide/parameters/#parameter-validation","title":"Parameter Validation","text":""},{"location":"user-guide/parameters/#automatic-validation","title":"Automatic Validation","text":"<p>DisruptSC validates parameters on startup:</p> <pre><code># Example validation checks\nassert 0 &lt;= utilization_rate &lt;= 1, \"Utilization rate must be 0-1\"\nassert nb_suppliers_per_input &gt;= 1, \"Must have at least 1 supplier\"\nassert io_cutoff &gt;= 0, \"IO cutoff cannot be negative\"\n</code></pre>"},{"location":"user-guide/parameters/#custom-validation","title":"Custom Validation","text":"<p>Add custom validation to your parameter files:</p> <pre><code># Parameter constraints (checked automatically)\n_validation:\n  io_cutoff:\n    min: 0\n    max: 1\n    description: \"Input-output coefficient threshold\"\n  utilization_rate:\n    min: 0.1\n    max: 1.0\n    description: \"Firm capacity utilization\"\n</code></pre>"},{"location":"user-guide/parameters/#parameter-examples","title":"Parameter Examples","text":""},{"location":"user-guide/parameters/#baseline-configuration","title":"Baseline Configuration","text":"<pre><code># parameter/user_defined_Cambodia.yaml\nsimulation_type: \"initial_state\"\nt_final: 1\ntime_resolution: \"day\"\nio_cutoff: 0.01\nutilization_rate: 0.8\nwith_transport: true\ncapacity_constraint: false\n</code></pre>"},{"location":"user-guide/parameters/#disruption-scenario","title":"Disruption Scenario","text":"<pre><code>simulation_type: \"disruption\"\nt_final: 90\nevents:\n  - type: \"transport_disruption\"\n    description_type: \"edge_attributes\"  \n    attribute: \"highway\"\n    value: [\"primary\"]\n    start_time: 10\n    duration: 30\nwith_transport: true\ncapacity_constraint: true\nadaptive_inventories: true\n</code></pre>"},{"location":"user-guide/parameters/#high-performance-configuration","title":"High-Performance Configuration","text":"<pre><code># Large-scale model optimization\ncutoff_firm_output:\n  value: 5000000\n  unit: \"USD\"\ncutoff_sector_output:\n  value: 100000000\n  unit: \"USD\"\nsectors_to_exclude: [\"SER_*\"]\ntransport_to_households: false\nuse_route_cache: true\nparallelized: true\nmax_workers: 8\n</code></pre>"},{"location":"user-guide/parameters/#monte-carlo-analysis","title":"Monte Carlo Analysis","text":"<pre><code>simulation_type: \"disruption_mc\"\nmc_repetitions: 500\nmc_parallel: true\nmc_seed: 12345\nevents:\n  - type: \"transport_disruption\"\n    description_type: \"random_edges\"\n    probability: 0.1\n    start_time: 10\n    duration: 20\n</code></pre>"},{"location":"user-guide/parameters/#parameter-tuning-guidelines","title":"Parameter Tuning Guidelines","text":""},{"location":"user-guide/parameters/#economic-realism","title":"Economic Realism","text":"<ul> <li>io_cutoff: Start with 0.01, increase to reduce model size</li> <li>utilization_rate: 0.7-0.9 for most economies</li> <li>target_margin: 0.15-0.25 typical for most sectors</li> <li>inventory_duration_targets: 3-30 days depending on sector</li> </ul>"},{"location":"user-guide/parameters/#computational-performance","title":"Computational Performance","text":"<ul> <li>Reduce model size: Increase cutoff values</li> <li>Speed up routing: Enable route caching</li> <li>Memory optimization: Exclude service sectors if not needed</li> <li>Parallel processing: Enable for large models</li> </ul>"},{"location":"user-guide/parameters/#disruption-realism","title":"Disruption Realism","text":"<ul> <li>Start small: Begin with short, localized disruptions</li> <li>Gradual recovery: Use realistic recovery rates</li> <li>Multiple scenarios: Test range of disruption severities</li> <li>Validate impacts: Compare with historical data when available</li> </ul>"},{"location":"user-guide/parameters/#sensitivity-analysis","title":"Sensitivity Analysis","text":""},{"location":"user-guide/parameters/#parameter-sensitivity-testing","title":"Parameter Sensitivity Testing","text":"<pre><code># Example sensitivity analysis\nimport itertools\nimport subprocess\n\n# Parameters to test\nio_cutoffs = [0.005, 0.01, 0.02, 0.05]\nutilization_rates = [0.7, 0.8, 0.9]\n\n# Run all combinations\nfor io_cutoff, util_rate in itertools.product(io_cutoffs, utilization_rates):\n    cmd = [\n        \"python\", \"disruptsc/main.py\", \"Cambodia\",\n        \"--io_cutoff\", str(io_cutoff),\n        \"--utilization_rate\", str(util_rate)\n    ]\n    subprocess.run(cmd)\n</code></pre>"},{"location":"user-guide/parameters/#key-sensitivity-parameters","title":"Key Sensitivity Parameters","text":"<ol> <li>io_cutoff - Affects model size and economic completeness</li> <li>utilization_rate - Influences production capacity and resilience</li> <li>nb_suppliers_per_input - Controls supply chain redundancy</li> <li>weight_localization - Determines spatial trade patterns</li> <li>inventory_duration_targets - Affects shock absorption capacity</li> </ol>"},{"location":"user-guide/parameters/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/parameters/#common-parameter-issues","title":"Common Parameter Issues","text":"<p>Model too large</p> <p>Solution: Increase cutoff parameters <pre><code>cutoff_firm_output:\n  value: 10000000  # Increase from 1000000\nio_cutoff: 0.05    # Increase from 0.01\n</code></pre></p> <p>Unrealistic results</p> <p>Solution: Check economic parameters <pre><code>utilization_rate: 0.8    # Not 0.95+\ntarget_margin: 0.2       # Not 0.5+\ntransport_share: 0.2     # Not 0.8+\n</code></pre></p> <p>Slow performance</p> <p>Solution: Enable performance optimizations <pre><code>use_route_cache: true\ntransport_to_households: false\nsectors_no_transport_network: [\"SER\", \"UTI\", \"TRA\"]\n</code></pre></p>"},{"location":"user-guide/parameters/#parameter-debugging","title":"Parameter Debugging","text":"<p>Enable detailed logging to debug parameter issues:</p> <pre><code>logging_level: \"DEBUG\"\nexport_files: true\n</code></pre> <p>Check the execution log for parameter validation messages:</p> <pre><code>grep -i \"parameter\\|validation\\|warning\" output/Cambodia/latest/exp.log\n</code></pre>"},{"location":"user-guide/parameters/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/parameters/#development-workflow","title":"Development Workflow","text":"<ol> <li>Start simple - Use default parameters initially</li> <li>Iterative refinement - Change one parameter at a time</li> <li>Validate results - Compare with known benchmarks</li> <li>Document changes - Track parameter modifications</li> <li>Sensitivity testing - Test parameter robustness</li> </ol>"},{"location":"user-guide/parameters/#production-settings","title":"Production Settings","text":"<ol> <li>Lock parameters - Use specific versions for production</li> <li>Archive configs - Save parameter files with results</li> <li>Validate inputs - Always validate before production runs</li> <li>Monitor performance - Track runtime and memory usage</li> <li>Result validation - Check output reasonableness</li> </ol>"},{"location":"user-guide/parameters/#collaboration","title":"Collaboration","text":"<ol> <li>Standardize configs - Use consistent parameter names</li> <li>Document rationale - Explain parameter choices</li> <li>Version control - Track parameter file changes</li> <li>Share configs - Distribute validated parameter sets</li> <li>Peer review - Have others review parameter choices</li> </ol>"},{"location":"user-guide/tutorial/","title":"Tutorial","text":"<p>To be developed</p>"}]}